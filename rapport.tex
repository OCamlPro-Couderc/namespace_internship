\documentclass[11pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[left=2.5cm,right=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
\usepackage{syntax}
\usepackage{cite}

\title{
  \textbf{Rapport de stage} \\
  Master 2 Recherche : \emph{Science et Technique du Logiciel}
  \\ - \\
  Proposition, formalisation et implémentation d'un mécanisme de namespaces
  pour OCaml\\ %% - \\
  %% \textsc{Inria}, en collaboration avec \textsc{OCamlPro}\\ - \\
}

\author{\textsc{Pierrick Couderc} \\
  Université Pierre et Marie Curie - Paris VI \\ - \\
  Sous la direction de \textsc{Fabrice Le Fessant} \\
  Inria \& OCamlPro
}

\date{6 Septembre 2014}

\setlength{\grammarindent}{8em} % increase separation between LHS/RHS 

\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      %% commentstyle=\tt\color{bluegreen},
                      stringstyle=\color{red},
                      identifierstyle=\ttfamily,
                      keywordstyle=\color{blue},
                      basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}


\lstnewenvironment{C}
                  {\lstset{
                      language=C,
                      breaklines=true,
                      %% commentstyle=\tt\color{bluegreen},
                      stringstyle=\color{red},
                      identifierstyle=\ttfamily,
                      keywordstyle=\color{blue},
                      basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstnewenvironment{JS}
                  {\lstset{
                      language=Javascript,
                      breaklines=true,
                      %% commentstyle=\tt\color{bluegreen},
                      stringstyle=\color{red},
                      identifierstyle=\ttfamily,
                      keywordstyle=\color{blue},
                      basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}


\lstnewenvironment{Python}
                  {\lstset{
                      language=Python,
                      breaklines=true,
                      %% commentstyle=\tt\color{bluegreen},
                      stringstyle=\color{red},
                      identifierstyle=\ttfamily,
                      keywordstyle=\color{blue},
                      basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}

\begin{document}

\maketitle

\section*{Remerciements}

J'aimerai bien sûr remercier Fabrice Le Fessant pour m'avoir proposé ce stage,
pour son encadrements et ses nombreuses idées.

Evidemment, j'aimerai remercier l'Inria pour m'avoir acceuilli au sein de
l'IRILL, à Didier Rémy et Gabriel Scherer pour m'avoir acceuilli dans leur
bureau et avec qui j'ai pu discuter et partager nos points de vue sur le
sujet. Egalement à l'équipe de l'IRILL, notamment Roberto Di Cosmo, Vincent
Balat et Jérôme Vouillon pour m'avoir acceuilli.

Je n'oublie bien sûr évidement pas tous les stagiaires de l'IRILL, notamment
Romain, Enguerrand, Ali, Julien, Béatrice et surtout Rémy qui deux fois par
semaine quittait le confort du LIP6 pour venir partager notre bureau et par
conséquent faire chuter notre productivité. Finalement, je remercie l'équipe
d'OCamlPro avec qui j'ai eu la chance de travailler, discuter, rigoler, etc, et
avec qui j'espère l'entente et la collaboration continuera durant les trois
années à venir.

Il n'y a pas que ce stage qui compte, et sans mes chers collègues APR l'année
qui s'est déroulée n'aurait pas été ce qu'elle a été. Merci à Pierre, I\~nigo,
Roven, Vincent, Matthieu et Mathieu, mais également à Emmanuel Chailloux et
Frédéric Peschanski \footnote{Malgré Haskell...} qui auront su nous acceuillir,
nous encadrer tout au long de l'année, et évidemment pour leur pédagogie si
particulière.

J'aimerai tout de même remercier une nouvelle fois Fabrice et Didier, le premier
pour m'acceuillir au sein d'OCamlPro pour les trois prochaines années pour
travailler sur ma thèse, et dont le sujet est l'idée du second protagoniste. Et
d'avance, je remercie Michel Mauny et Jacques Garrigue d'avoir accepté
d'encadrer ce travail de recherche, avec Grégoire Henry au sein d'OCamlPro.


\begin{abstract}
Les namespaces peuvent se situer à plusieurs niveaux dans un programme, mais
toujours avec la même utilité : distinguer des noms par un mécanisme de
``provenance'', sans quoi ceux-ci auraient pu entrer en conflit. Par exemple,
les namespaces de C++ permettent de distinguer des valeurs, des fonctions ou
des classes, et les packages de Java ou Scala de distinguer et d'organiser des
classes. Le sujet des namespaces est récurrent au sein de la communauté OCaml,
sans toutefois avoir réussi à en dégager une véritable solution. La notion
d'espaces de noms existe déjà dans le langage grâce notamment au système très
efficace de modules, mais trouve ses limitations au moment du passage à
l'échelle. 

L'objectif de ce stage est d'imaginer et implémenter une solution qui
viserait à satisfaire l'ensemble des participants ou une majorité, mais surtout
en proposant une solution effective et implémentée dans le compilateur OCaml. Le
résultat est un méchanisme d'en-tête de fichiers qui permet de déclarer le
namespace de l'unité de compilation mais aussi d'importer des modules provenant
d'autres namespaces, tout en s'inspirant de l'expressivité d'autres langages, en
particulier Scala.

De plus, OCaml est un langage particulièrement efficace à l'utilisation grâce à
son mécanisme de foncteur, qui permet d'abstraire des modules sur une interface
et de l'instancier le plus tardivement possible. Un autre objectif est de
transcrire cette idée au niveau des namespaces. Le résultat est un nouveau type
d'unités de compilation appelées \emph{unités functorisées}, qui permettent de
définir des namespaces dont certaines des composantes sont totalement
abstraites. L'intérêt est de pouvoir définir des bibliothèques génériques
utilisant des implémentations définies par l'utilisateur et qui peuvent être
instanciées tardivement.
\end{abstract}

\tableofcontents

\chapter{Introduction}

Dans le monde des langages, il est souvent utile de pouvoir réutiliser des noms
de fonctions ou de valeurs à différents endroits d'un programme, notamment en
terme de lisibilité du code écrit, mais également pour l'utilisateur qui devra
faire appels à celles-ci. Si de tels moyens n'existaient pas, en d'autre terme
s'il n'existait aucune portée dans le langage, l'utilisateur se verrait
contraint d'écrire et d'imaginer des noms affreusement longs pour éviter de
potentiels conflits à la compilation et/ou à l'exécution de son
programme. Typiquement, si on suppose que deux structures de données,
\texttt{Map} et \texttt{Hashtbl}, pour lesquelles il existe des opérations
relativement identiques (créer, ajouter, retirer, itérer, etc), les noms des
fonctions seraient de l'ordre de \texttt{hashtbl\_add, hashtbl\_find} et
respectivement pour Map. Si maintenant quelqu'un voulait utiliser sa propre
implémentation de tables de hashage, il se retrouverait à écrire des noms
suffisament longs pour éviter tout conflit.

En terme de passage à l'échelle, ce problème est évident : il devient
pratiquement impossible d'écrire un programme correct et lisible, notamment
parce qu'un programme mesure en général quelques milliers de lignes, mais aussi
parce que certains parties du code font appel à des bibliothèques externes dont
une partie des éléments sont abstraits. Ce problème est résolu notamment par ce
que l'on nomme un \textbf{espace de noms} (ou \texttt{namespace}).

Il existe de nombreux moyens de simuler des espaces de noms, par exemple à
l'aide de la portée lexicale ou syntaxique dans le programme : tout nom défini à
l'intérieur d'un bloc n'est visible que par lui et par conséquent aucune
fonction ou valeur de même nom n'est plus atteignable, et ce qui est déclaré
dans le bloc n'est pas visible vers l'extérieur. Ce principe de portée
s'applique aussi bien aux blocs, aux fonctions mais aussi aux \emph{unités de
  compilation} (autrement dit, aux fichiers). Ce mécanisme de portée est un fait
admis dans les langages de programmation, bien qu'il existe des langages où la
notion de portée est différente, notamment Javascript où les seuls espaces de
noms sont les fonctions \cite{EcmaScript}\footnote{En vérité, toute déclaration
  est remontée au début du corps de la fonction. On peut donc définir une
  fonction dans un \texttt{if (false) \{ ... \}} et tout de même y accéder
  partout ailleurs dans le corps de la fonction.}.

OCaml en particulier est un langage fonctionnel fortement typé et possédant
notamment un système de modules dont l'utilité est de pouvoir définir des
espaces de noms et d'être paramétriques sur d'autres modules. Ces applications,
ou \emph{foncteurs}, permettent de définir des modules abstraits sur une
interface et donc une meilleure réutilisabilité du code. Un module peut être
déclaré à n'importe quel endroit du code, et une unité de compilation est
elle-même un module, à la différence près qu'elle ne peut être functorisée.

En revanche, malgré un système de modules fort, le passage à l'échelle peut
parfois être problématique : en terme d'architecture de programme, il n'est pas
rare de retrouver les mêmes noms d'unité de compilation entre deux
bibliothèques. Par exemple, une unité de compilation \texttt{Utils} est
généralement très utilisée pour les fonctions génériques qui sont utilisées par
tout le reste du code. De ce fait, il devient impossible de générer un programme
correct qui auraient des unités de même nom, et il incombe alors au developpeur
de préfixer ses modules pour éviter de probables conflits. Il devient dès lors
nécessaire de trouver une solution à ce problème pour permettre d'avoir d'autres
discriminants que le nom du module pour permettre une édition des liens
correcte. Autrement dit, il devient nécessaire d'avoir une notion d'espace de
noms pour les unité de compilation.

L'intérêt de ce stage est donc de trouver une solution à ce problème en étudiant
les moyens mis en oeuvre par les autres langages pour résoudre ce problème. En
outre, un autre objectif plus original est de trouver une solution pour utiliser
des foncteurs au niveau de ces \emph{namespaces} et ainsi obtenir des
bibliothèques paramétriques mais dont la gestion et l'instanciation de ces
foncteurs se ferait automatiquement par le compilateur. La difficulté réside
particulièrement dans la compréhension du compilateur OCaml, la manière dont
sont liées entre-elles les unités de compilation et la compréhension du langage
intermédiaire pour générer ces foncteurs particuliers qui n'existent pas dans le
langage.

Ce stage a été réalisé au sein de l'Inria et en collaboration avec OCamlPro,
sous la direction de Fabrice Le Fessant.

\chapter{\'{E}tat de l'art}

\section{Espace de noms, portée lexicale et dynamique}

Comme expliqué dans l'introduction, la portée lexicale est devenu quelque chose
d'admis dans le milieu des langages de programmation. La spécification d'ALGOL
60 \cite{Naur:1960:RAL:367236.367262} en donne d'ailleurs une définition,
définissant le \emph{Scope} comme étant \emph{``l'ensemble des instructions dans
  lequel la déclaration de l'indentifiant et sa valeur sont
  valides''}. Cette notion de portée est très importante puisqu'elle permet de
réutiliser des noms localement sans affecter ceux déjà déclarés avec le même
nom. Prenons un exemple écrit en C :
\begin{C}
void f(x) {
  if (x == 1) {
    int y = 42;
  }
  printf("%d\n", y};
}
\end{C}
Celui-ci ne sera pas correct, peut importe le résultat du test \texttt{if (x ==
  1)}. La variable est déclarée dans le bloc de l'instruction \texttt{if} et par
conséquent ne peut être utilisée à l'extérieur. On parlera ici de portée
lexicale, puisqu'il est possible de savoir en lisant le code que la variable y
ne sera pas accessible. On parle également de portée statique car le compilateur
sait exactement à la compilation quelle variable utiliser. Par exemple :
\begin{C}
int x = 2;
void f() {
  printf("%d\n", x}; // Affichera 2
}

void g() {
  int x = 4;
  f(); // Affichera 2
}
\end{C}

La portée dynamique est à opposer à la portée statique. La variable utilisée
par une fonction dépendra alors du contexte d'appel. Par exemple, si on reprend
le code précédent mais en supposant que la portée en C est dynamique :
\begin{C}
int x = 2;
void f() {
  printf("%d\n", x}; // Affichera 2
}

void g() {
  int x = 4;
  f(); // Affichera 4
}
\end{C}
Alors \texttt{g()} affichera 4 car au moment de l'appel de \texttt{f()}, la
variable x a pour valeur 4. Ainsi, la portée dynamique est résolue à l'exécution
et par conséquent les erreurs interviendront à ce moment précis.

Néanmoins, il peut être intéressant de voir que certains langages comme Python
\cite{python-spec} ont un concept de portée lexicale seulement pour le corps des
fonctions, et est dynamique pour le reste. Par exemple, l'exemple suivant en
Python est correct :
\begin{Python}
def f(): 
    if True:
        x = 2
    print x

f() # Affichera 2
\end{Python}
Contrairement à notre premier exemple en C, \texttt{x} est déclaré dans le corps
du \texttt{if} mais peut-être accédé en dehors de celui-ci. Il en va de même
pour les fonctions locales :
\begin{Python}
def f():
    if True:
        def g():
            print 42
    g()

f() # Affichera 42
\end{Python}

Enfin, il est également intéressant de citer Javascript où le concept de portée
lexicale est bien plus faible. En effet, le code suivant :
\begin{JS}
function f() {
  if (true) {
    function g(i) {
      console.log("Well..." +i);
    };
  }
  if (false) {
    function g(i) {
      console.log("How?!" +i);
    };
  }
  g(42);
}

f();
\end{JS}
affichera ``How?!42''. Le principe de Javascript est que toutes les déclarations
sont remontées au début du corps de la fonction où elles sont utilisées. Pour
des valeurs normales, l'interpréteur différencie tout de même déclaration et
affection, mais pour des fonctions déclarées de la manière suivante il ne fait
pas la distinction. Pour faire cette différence, il aurait fallu que la fonction
\texttt{g} soit écrite de la mankère suivante : 
\begin{JS}
var g = function(i) { ... }
\end{JS}

Bien que n'étant pas fondamentalement utile pour le sujet traité, il est
vraiment important de comprendre le rôle de la portée et des espaces de noms
dans n'importe quel programme. S'il n'y avait aucune différenciation, les
risques pourraient être catastrophiques, puisque certaines variables pourraient
entraîner des erreurs à cause d'un type différent ou d'une valeur erronée, voire
des valeurs inattendues dans le cas de langages où la mutabilité est
possible. Notre problématique touche des objets à un niveau bien plus haut
puisqu'il s'agit de différencier des unités des compilation dont les noms
pourraient être en conflit.

\section{Unités de compilation}

Un programme est rarement constitué d'un seul fichier mais plus généralement
d'un ensemble de fichiers, appelés aussi \emph{unités de compilation}. Une unité
de compilation possède généralement une interface et une implémentation, la
première étant une description sur la manière d'utiliser la seconde. Il s'agit
de l'interface d'entrée pour d'autres programmes pour pouvoir utiliser le code
de celle-ci. On parle alors de compilation séparée
\cite{Cardelli97programfragments}.

Ainsi, un programme est un ensemble d'unité de compilation ordonnée selon leur
dépendance. Néanmoins, ces unités ne peuvent être liées entre elles qu'à la
condition qu'elles soient compatibles. Autrement dit, dès qu'une unité en
utilise une autre, donc qu'il s'agit d'une ses dépendances, elle doit être
recompilée si l'une de ses dépendances l'a été pour s'assurer de leur
compatibilité. Un programme est ainsi un ensemble d'équations à résoudre
pour pouvoir être correctement compilé \cite{Drossopoulou99afragment}. On
retrouve d'ailleurs une formalisation simplifiée d'un programme correct en terme
d'unités de compilation en annexe.

\section{Namespaces et packages}

Le principe de namespaces existe déjà dans plusieurs langages, on peut le
retrouver par exemple en C++\cite{cppspec} où il est possible de créer des
namespaces qui contiennent des valeurs, des classes ou des fonctions, et qui
peuvent être déclarés dans plusieurs unités différentes. Néanmoins, cette
solution ne correspond pas à celle vers laquelle nous nous dirigeons, à savoir
un mécanisme pour différencier des unités de compilation de même nom. En ce
sens, notre idée est à rapprocher fortement des packages de Java\cite{java-spec}
et en particulier Scala\cite{scalaspec}. En effet, dans ces deux langages les
packages permettent d'organiser des classes sous une hiérarchie et ainsi
d'utiliser de manière conjointes des classes de même nom en utilisant le chemin
complet. Néanmoins, ce choix se justifie dans ces deux langages puisque la 
classe est l'unité de base du langage. Il est donc nécessaire d'avoir ce
mécanisme de noms longs pour les différencier. En revanche, les clauses
d'importation de Scala permettent une meilleure expressivité en donnant la
possibilité d'importer plusieurs classes d'un package mais aussi en les aliasant
ou en les masquant dans le cas où tout le package est importé. Par exemple :
\begin{verbatim}
import mypackage.{Obj; _; Point => _}
import another_package.{Obj2 => O; Point}
\end{verbatim}
où dans ce cas précis l'objet \texttt{Obj} ainsi que tous ceux dans
\texttt{mypackage} sont importés, à l'exception de \texttt{Point}, tandis que
\texttt{Obj2} (renommé en \texttt{O}) et \texttt{Point} sont importés de
\texttt{another_package}.

Un travail récent a été fait autour d'Haskell pour résoudre notamment
le problème de compilation séparé\cite{KilpatrickDJM14} : en effet, le système
de modules d'Haskell ne possède pas de \emph{signatures}, et par conséquent
n'est pas capable de compiler de manière distribuée un programme. Une unité de
compilation n'est compilable qu'à partir du moment où toutes ses dépendances le
sont. Le résultat est un langage de packages au dessus d'Haskell, qui permet en
outre de \emph{typer-checker} un programme sans donner d'implémentation pour
chacune des dépendances grâce à des interfaces de modules, mais également un
système de packages pour distinguer les modules. L'intérêt de cette solution est
qu'elle met également en avant un mécanisme de \emph{trous} pour générer des
packages plus ou moins génériques, où l'instanciation peut se faire tardivement.

OCaml quand à lui possède déjà son système de modules\cite{Leroy00} qui fait
office de mécanisme de namespaces : les fonctions et valeurs peuvent être ainsi
préfixées d'un chemin, permettant alors de différencier celles-ci à l'exécution
et à la compilation. Néanmoins, deux unités de compilation ne peuvent coexister
dans un programme si celles-ci ont le même nom.

Il est important de s'intéresser aux nombreuses discussions de la communauté
\cite{ocaml-platform} et particulièrement aux différentes propositions émises
par certains mainteneurs du compilateur\cite{ocaml-proposals}, notamment un
langage formel de description d'environnement\cite{remy-scherer-prop}, idée
initialement introduite dans la proposition de Fabrice Le
Fessant\cite{lefessant-prop} et décrivant ainsi les possibilités attendues pour
des namespaces. Jusqu'ici dans le langage plusieurs solutions alternatives
étaient disponibles pour palier au manque de namespaces : les noms longs, les
packs de modules et les modules utilisés comme namespaces à l'aide d'alias. Des
exemples concrets sont donnés à la fois dans le chapitre suivant mais aussi en
annexe \ref{appendix-soa} (page \pageref{appendix-soa}), où une formalisation
simplifiée est donnée pour exprimer ce que représente en terme de dépendances et
d'unités de compilation un programme correct. Cette annexe présente les
changements intervenus avec l'ajout des alias au de modules (qui existaient mais
sont désormais partie intégrante du système de types) et des dépendances dites
faibles.

L'intérêt de namespaces dans le langage est réel comme le prouvent les
discussions et les différentes propositions. Malheureusement, ces derniers
étaient bien souvent trop spécifiques à un besoin ou ne plaisaient pas à
l'ensemble des participants. Finalement, aucun accord n'a pu être trouvé et la
communauté s'est contenté d'utiliser les techniques décrites dans la section
suivante.

\section{Namespaces et OCaml}

Dans l'implémentation actuelle d'OCaml, il est impossible de lier deux unités de
compilation de même nom, ou du moins d'y référer de manière explicite. En effet,
lorsqu'un programme est compilé en \emph{bytecode}, le code d'initialisation des
deux modules sera bien executé, en revanche seul le module lié en premier sera
effectivement accessible. Dans le cas de compilation native (en assembleur), le
compilateur ne pourra générer un programme qui sera correct étant donné que les
deux unités définiront des symboles identiques (par exemple, si les modules
s'appellent tous deux \texttt{Mod}, chacun aura forcément le symbole
\texttt{camlMod_entry} défini dans son assembleur).

La solution adoptée par l'ensemble des développeurs est de préfixer leurs
modules par le nom de la bibliothèque dont elle est issue. Cette solution est
efficace mais oblige l'utilisateur à devoir utiliser des noms parfois longs dans
son programme. Bien qu'il ne s'agisse que d'un problème en terme de praticité,
il peut être intéressant de proposer une solution plus générale à ce problème.

Dans ce sens, l'une des solutions utilisées par les développeurs est de créer
des \texttt{packs} de modules : il s'agit alors de plusieurs unités de
compilation regroupées au sein d'une seule qui fait alors office d'espace de
nom. Cette solution est déjà plus intéressante, car elle permet de distribuer
une bibliothèque sous la forme d'un seul objet, mais est également plus souple à
l'utilisation. En effet, chaque module est donc accessible à l'aide du chemin
\texttt{<nom\_du\_pack>.<nom\_de\_l'unité>} : le compilateur transforme chacune
des unités du pack en sous-module. Ainsi, il suffit d'ouvrir le module qui fait
office de pack pour utiliser les noms originaux. En revanche, cette solution a
plusieurs défauts :
\begin{itemize}
\item elle oblige à emporter \textbf{tous} les modules du pack, même si un seul
  est utilisé;
\item il est impossible d'avoir du code d'initialisation dans ce module-pack,
  par exemple pour y inclure des fonctions ou opérateurs utiles pour tous les
  modules du pack (pour simuler le comportement de Pervasives par exemple).
\end{itemize}
En résumé, il n'y a aucun contrôle sur le contenu effectif du pack, il n'est
possible que d'y ajouter des unités de compilation mais aucune autre opération
n'est possible.

Une solution adoptée par d'autres tels que Jane Street pour leur bibliothèque
\emph{Core} ou les développeurs de la bibliothèque \emph{Batteries Included} est
d'utiliser un module d'alias. En d'autre termes, un module qui est une suite
d'alias d'autres modules, permettant ainsi d'avoir l'avantage du pack mais sans
le second inconvénient. En effet, puisque ce module est écrit par le développeur
et non plus généré automatiquement par le compilateur, il est possible d'y
inclure du code qui sera directement utilisable dès lors que ce ``module
namespace'' sera ouvert. En revanche, avant la version 4.02 d'OCaml, cette
solution nécessitait tout de même de donner explicitement au compilateur tous
les modules référencés dans ce dernier.

La prochaine version du compilateur règle ce problème en rajoutant (entre
autres) une notion de dépendances faibles (ou transparentes comme son auteur,
Jacques Garrigues, les appelle). Ainsi il en résulte trois propriétés
intéressantes:
\begin{enumerate}
\item un alias se propage, i.e. il peut être instancié tardivement, dans une
  autre unité de compilation;
\item tant qu'un alias n'est pas utilisé, il n'est pas nécessaire à la
  compilation; 
\item son interface peut ne pas être présente au moment de la compilation du
  ``module namespace''.
\end{enumerate}
De plus, deux autres fonctionnalités ont été rajoutées:
\begin{itemize}
\item une option \texttt{-open} qui permet d'ouvrir un module avant même de
  commencer à typer le programme;
\item la sémantique du \texttt{-o} a été modifiée et permet désormais de choisir
  le nom interne de l'unité de compilation qui sera générée (jusque là,
  seulement le nom du fichier changeait, son nom de module était celui du
  \texttt{.ml}).
\end{itemize}

Ces traits permettent ainsi de simuler des namespaces, mais de manière non
intuitive, et demande de mettre en place un schéma de compilation relativement
compliqué. Un exemple simple serait le suivant:

Supposons que l'on écrive deux modules \texttt{set.ml} et \texttt{map.ml}, et
dont \texttt{Set} est dépendant de \texttt{Map} (on suppose naïvement ici qu'un
set est un mapping de valeurs vers unit). On utilise un module \texttt{lib.ml}
qui fait office de ``module namespace''. Le contenu des trois fichiers est le
suivant:

\begin{OCaml}
(* map.ml *)
...

(* set.ml *)
...
module Make (Arg) =
struct
  module TMap = Map.Make(Arg)
  ...
end
...

(* lib.ml *)
module Map = Lib_map
module Set = Lib_set
\end{OCaml}

Le lecteur attentif remarquera que le nom dans \texttt{lib.ml} des deux modules
aliasé est différent de leur nom d'origine, et de plus, que \texttt{set.ml} fait
explicitement référence à \texttt{Map} (donc \texttt{map.ml}). L'astuce ici est
d'utiliser les fonctionnalités introduite précédemment :
\begin{enumerate}
\item \texttt{lib.ml} est d'abord compilé, mais comme ce module ne contient que
  des alias et d'après la propriété (2) des alias. On donne également l'option
  \texttt{-no-alias-deps} qui permet d'utiliser la proriété (1).
\item \texttt{map.ml} est compilé avec l'option \texttt{-o lib\_map.ml}.
\item \texttt{set.ml} est ensuite compilé à l'aide de les options \texttt{-o
  lib\_set.ml} et \texttt{-open Lib}.
\end{enumerate}

La dernière étape permet donc de simuler le namespace : la directive
\texttt{-open Lib} permet de propager de manière transparente les alias de Lib
dans \texttt{set.ml} et ainsi de ne pas avoir à utiliser le nom long
\texttt{Lib\_map} (et de ne pas écrire les noms de fichiers longs). Cette
technique peut paraître relativement complexe, mais a été avancée comme la
non-nécessité de devoir inclure un véritable mécanisme de namespaces dans le
langage. Elle nécessite un schéma de compilation relativement complexe, capable
de gérer de manière transparente les changements de noms de modules et les
dépendences qui semblent être mutuellement récursives. L'intérêt est seulement
le fait que les alias non utilisés n'auront pas à être liés à la compilation.

Cette solution n'est pas satisfaisante, tout d'abord à cause de cette
gymnastique non intuitive pour comprendre le schéma de compilation, mais
également parce qu'elle nécessite un véritable \emph{système de build} pour être
capable de l'utiliser. De plus, il manque une propriété importante que l'on
pourrait attendre des namespaces : l'extensibilité.

\chapter{Problématique et Solution}

Pour une meilleure compréhension de ce rapport, il est nécessaire de définir
certains termes qui seront mentionnés de manière régulières. Ainsi, un module
fera toujours référence à une unité de compilation et non un module déclaré dans
le fichier, sauf lorsque le contraire est indiqué : cette définition est logique
puisque la problématique étudiée ici se concentre sur les unités de compilation
uniquement. 


\medskip

Au final, la problèmatique de ce stage est d'imaginer et prototyper un mécanisme
de \emph{namespaces} pour OCaml, dont l'utilisation soit simple et facilement
compréhensible, mais qui en plus de cela ne demande pas un schéma de compilation
particulier pour être efficace. L'idée est également de trouver une
solution pour les namespaces functorisés, qui permettrait de mettre en oeuvre
des bibliothèques totalement génériques et instanciées par l'utilisateur.

Dans le cadre d'un système efficace de namespaces, plusieurs solutions ont été
proposées et envisagées. Il faut savoir que ce sujet est étudié informellement
depuis déjà longtemps au sien de la communauté et plusieurs contributeurs ont
proposé une solution. En revanche, celles-ci étant souvent éloignées et les avis
divergeants, aucun compromis n'a été établi vers une proposition qui pourrait
satisfaire le plus de monde. Le but est de trouver ce compromis en proposant une
solution concrète avec un prototype. L'intérêt est d'éviter de relancer une
discussion sur la manière dont doit être ajoutée cette fonctionnalité, mais
plutôt de discuter d'une solution effective et l'améliorer en fonction des avis
reçus.

En ce sens, il peut être intéressant de voir les grands axes qui ont été étudiés
pour des solutions à ces propositions et de quelle manière notre proposition
finale la rejette ou au contraire s'en inspire.

Les objectifs de notre solution sont les suivants :
\begin{itemize}
\item \^{E}tre consistant, en d'autres termes ne pas devoir jongler entre le
  langage et le \emph{build system};
\item Simplicité en terme de construction et d'utilisation;
\item Orthogonalité avec le système de types;
\item Pas de changement dans la sémantique du langage;
\item Etre compatible avec le schéma de compilation actuel, i.e. ne demande
  pas d'outils particuliers supplémentaires.
\end{itemize}

Dans chacune des propositions existantes, au moins un point n'était pas
respecté. Par exemple, l'une des solutions étaient d'étendre le nom des modules
avec un préfixe qui serait le nom du namespace :
\texttt{<namespace>-<module>.ml}. Cette solution relativement simple visait à ne
pas changer en profondeur le compilateur, mais semblait trop simple. Dans le
langage, pour la plupart des solutions, le chemin des modules était étendu avec
un namespace. Par exemple, l'utilisation d'une unité de compilation se faisait
de la manière suivante :
\texttt{Chemin\#Du\#Namespace\#Module.Sous\_module}. 

Une solution était également d'ajouter un nouveau type de fichier de description
de namespaces, mais cette solution n'apportait finalement pas la simplicité
désirée. Finalement, durant la synthèse des différente solution émergeait un
concept important pour ces ensembles d'unité de compilation : un moyen de
décrire l'environnement de compilation. Ce concept était introduit par Fabrice
Le Fessant \cite{lefessant-prop} et repris dans la proposition de Didier Rémy et
Gabriel Scherer \cite{remy-scherer-prop}.

\section{Déclaration et implémentation de namespaces}

En partant de ce principe, il fallait donc trouver ce qu'était l'environnement
de compilation, comment celui-ci était généré et comment l'utilisateur pourrait
l'influencer : en effet, l'un des problèmes majeurs actuels est l'impossibilité
d'utiliser deux unités de compilation de même nom dans un programme. Si
l'environnement est capable de les distinguer cela ne poserait plus de
problème. Ce qui ressort également de ce problème est que pour que deux modules
de même nom puissent cohabiter dans le système de fichiers, ils doivent être
dans des dossiers distincts : le système de fichiers avec son organisation à
travers une hiérarchie de dossier est un espace de noms. Ainsi, un namespace
pourrait être la projection de l'organisation des modules sur le système de
fichiers.

Cette réflexion nous mène alors à la solution suivante :
\begin{itemize}
\item Un module = un fichier, donc un Namespace = un dossier \\ $\rightarrow$ le
  compilateur sait où trouver un module dans un namespace spécifique.
\item Pas de manipulation explicite des namespaces dans le coeur du langage pour
  éviter des possibles changements de sémantique \\
  $\rightarrow$ La déclaration des namespaces et l'import des unités de
  compilation se fait en en-tête du code, cet en-tête permet de décrire plus
  finement l'environnement de compilation.
\end{itemize}

De cette manière, le coeur du langage ne subit aucune modification, et de plus,
cela permet d'harmoniser la manière dont sont installées les bibliothèques, ou du
moins propose une organisation standard et permet de réduire le besoin d'outils
externes pour trouver un module (\emph{ocamlfind} par exemple). La syntaxe de
l'en-tête est présentée en annexe \ref{header-bnf}.


Dans cette syntaxe, il faut noter que l'en-tête est séparé en deux parties
distinctes. Tout d'abord, on remarque que le namespace auquel appartient l'unité
de compilation est déclaré explicitement, par exemple:
\begin{OCaml}
in namespace MyNamespace
\end{OCaml}
Cela permet au compilateur de récupérer de manière automatique tous les modules
susceptibles d'appartenir au même namespace. De plus, déclarer de manière
explicite permet au compilateur de générer le fichier dans le bon dossier. La
déclaration d'un namespace n'est en revanche pas obligatoire et permet à
n'importe quel programme écrit sans namespace d'être compatible.

La seconde partie est la plus intéressante et montre les possibilités de
déclaration de l'environnement de compilation. La déclaration des imports est
lue séquenciellement. Chaque ligne déclare l'ensemble des modules à importer
depuis l'environnement donné. Cet ensemble est déclaré par l'utilisateur, ce qui
lui permet de raffiner ses choix à la manière de Scala :
\begin{itemize}
\item En important module par module;
\begin{OCaml}
with MyNamespace.(M, N)
open M
\end{OCaml}
\item En important un module tout en l'aliasant;
\begin{OCaml}
with MyNamespace.(M as MyModule)
open MyModule 
\end{OCaml}
\item En important tous les modules;
\begin{OCaml}
with MyNamespace.(_)
open M (* importe de MyNamespace *)
\end{OCaml}
\item En masquant un module, pour ne pas inclure tous les modules dans
  l'ensemble généré par la contrainte précédente.
\begin{OCaml}
with MyNamespace.(_, M as _)
open M (* module qui n'etait donc pas dans MyNamespace *)
\end{OCaml}
\end{itemize}

Cet en-tête n'existe plus à partir de la phase de typage, et se calcule en deux
temps : l'ensemble des modules à rajouter à l'environnement est calculée puis le
résultat ajouté à l'environnement. Il ne change rien à la chaîne de compilation,
si ce n'est d'utiliser des informations de namespaces lors de la recherche de
modules dans l'environnement (\emph{load path}). Cet en-tête ajoute chaque nom
(ou alias) dans l'environnement, ainsi chaque module importé est directement
utilisable. Par conséquent, dans ce cas précis :
\begin{OCaml}
with Stdlib.List
and Core.List

open List
\end{OCaml}
le module effectivement ouvert sera le second importé. Un \emph{warning} est
ajouté au compilateur pour prévenir ce genre de cas où deux noms importés
entrerait en conflit. Il ne gère cependant que les noms importés depuis les
namespaces. Par exemple, si on importait seulement le module List de Core, on ne
pourrait plus utiliser un autre module List qui ne serait pas dans un namespace
mais le compilateur ne pourrait pas le découvrir (ou alors il serait nécessaire
de calculer son univers de compilation avant toute phase de typage).


Cependant, cet en-tête n'est pas suffisant pour gérer l'utilisation de modules de
même nom : il est donc nécessaire d'ajouter cette information dans l'unité de
compilation elle-même pour pouvoir l'utiliser comme discriminant lors de
l'édition des liens, mais aussi de modifier les symboles pour y introduire cette
information et donc permettre une différenciation.

Cette solution répond aux problèmes posés par les packs et les modules d'alias :
seuls les modules utilisés sont réellement nécessaires, et de plus un namespace
est totalement extensible. En effet, rien n'empêche un autre utilisateur
d'utiliser le même namespace pour y redéfinir certains modules ou en ajouter.

\paragraph{Modules ouverts automatiquement}

Une fonctionnalité manquante par rapport aux modules d'alias (ou ``modules
namespace'') est la possibilité d'avoir du code accessible de base pour tous les
modules. Ce qui a été décidé ici est donc de donner une sémantique particulière
aux unités de compilation ayant pour nom \emph{Pervasives}. Ainsi, chaque fois
qu'un namespace est utilisé et qu'il contient un module Pervasives, celui-ci est
automatiquement ouvert (sauf s'il est aliasé ou masqué dans les contraintes). De
plus, chaque module d'un namespace ouvre implicitement ce module.

\paragraph{Système de fichiers et namespaces}

Comme expliqué précédemment, les namespaces et le système de fichiers sont
étroitement liés, puisqu'un namespace sera traduit à la compilation en un
dossier. En revanche, le contraire n'est pas vrai : un dossier n'est pas
forcément un namespace. Par exemple, si le compilateur doit chercher le module
``Ns.A'', et qu'il existe un fichier \texttt{a.cmi} dans un dossier \texttt{ns},
si celui-ci n'est pas explicitement dans le namespace \texttt{Ns} alors il ne
s'agit pas du module recherché. En effet, les symboles générés sont dépendants
du namespace, il est donc impossible d'utiliser n'importe quelle unité pourvu
qu'elle soit dans le dossier qui pourrait correspondre. 

%% De plus, comme dans la sémantique actuelle du compilateur, l'ordre de \texttt{-I
%%   <dossier>} est important. Pour rappel, cette option permet de rajouter des
%% chemins où le compilateur peut rechercher les unités de
%% compilation. Actuellement, si le compilateur cherche un fichier \texttt{a.cmi},
%% il prendra celui qui se trouve dans le premier dossier dans l'ordre des
%% \texttt{-I}, en commençant par la racine. Pour les namespaces, l'ordre dans
%% lesquel sont recherchés les modules dans les sous-dossiers est le même.

\paragraph{Calcul des dépendances}

Un trait intéressant qu'apportent l'introduction de namespaces est qu'il est
possible syntaxiquement de calculer des dépendances. En effet, les modules sont
importés explicitement, par conséquent il est beaucoup plus facile de savoir de
quels modules le fichier actuel dépend et surtout, si le module référencé est un
sous-module venant d'un ``open'' ou un ``include'' ou non. La seule inconnue
reste le cas où l'import se fait à l'aide de \texttt{_} : à ce moment là,
lorsque la provenance d'un module ne peut pas être inférée depuis les imports,
il est possible de regarder dans les dossiers qui correspondent aux namespaces
dont tous les modules ont été importés. Il est également possible de lire les
premiers tokens des fichiers dont le nom correspond pour vérifier que le
namespace déclaré correspond à l'un de ceux utilisés.

\paragraph{Recherche d'unités de compilation}

Comme précédemment évoqué, les namespaces sont directement transformés en
dossiers sur le système de fichiers. Ainsi, lorsque le compilateur devra
compiler une unité, il devra regarder sur celui-ci pour trouver les
\texttt{cmis} correspondant aux dépendances. Il est possible de lui spécifier
plusieurs chemins dans le système où chercher, ainsi le cmi qui sera gardé sera
celui qui aura été trouvé en premier dans l'ordre des chemins. La recherche dans
des dossiers pour trouver des unités appartenant à des namespaces se fait de la
même manière : le premier cmi trouvé sera utilisé. Ce comportement est le même
pour les \texttt{cmos/cmxs} au moment de la création d'une archive ou d'un
exécutable.

\paragraph{Namespaces et structures}

Alternativement à la sémantique actuelle de l'import de modules qui sont
simplement ajoutés dans l'environnement, il est également possible de
transformer l'en-tête en un ensemble de structures pour utiliser explicitement le
chemin du namespace. Cela a pour conséquence de ne pas nécessiter un renommage
en cas de conflit, mais aussi d'utiliser des namespaces comme arguments de
foncteurs (ou comme modules de première classe). Par exemple, l'en-tête suivant
:
\begin{OCaml}
with Stdlib.(List; Map)
and Stdlib.Internals.(CamlinternalFormat)
\end{OCaml}
serait traduit en
\begin{OCaml}
module Stdlib =
  struct
    module List = ...
    module Map = ...
    module Internals =
      struct
        module CamlinternalFormat = ...
      end
  end
\end{OCaml}

\section{Alternative aux \emph{big functors}}

Le deuxième problème à résoudre est celui de trouver une contrepartie aux
\emph{big functors} pour les namespaces. Pour rappel, les big functors sont une
extension particulière des packs, qui permet au lieu de faire un simple module
comprenant pour sous-modules des unités de compilation d'avoir un pack
``paramétrique''. L'idée est ici d'englober ces sous-modules sous un foncteur, et
ainsi permettre d'abstraire certaines des dépendances de ces modules pour en
faire des arguments de ce foncteur. Ainsi, il devient possible d'avoir des packs
instanciés sous différentes implémentations.

Cette fonctionnalité, qui a été proposée et implémentée par Fabrice Le Fessant
\cite{lefessant-bigfunctors} était destinée à la version 3.12 du compilateur,
mais n'a jamais été fusionnée dans les sources officielles. Le patch est
néanmoins disponible sur le site d'OCamlPro. L'idée ici est donc d'imaginer et
d''implémenter un mécanisme qui permettrait d'avoir des namespaces
``génériques'', functorizés et ainsi de permettre une meilleure réutilisabilité
du code.

L'intérêt ici est donc de savoir dans quelle mesure le code était réutilisable
et facilement adaptable, mais aussi de trouver une solution simple à ce
problème. On peut voir cette fonctionnalité comme la contrepartie des ``trous''
de Backpack pour Haskell \cite{KilpatrickDJM14}. Ainsi, la solution à envisager
doit être capable d'avoir des modules qui soient abstraits et aussi de pouvoir
avoir des dépendances qui soient elle-mêmes functorizées sur les mêmes
arguments. Le résultat sera ce que l'on appelera des \emph{functor units}, ou
aussi des unité functorisées, qui sont un cas particulier d'unités de
compilation.

Ainsi, l'utilisation de cet functor units se fait en deux temps :
\begin{itemize}
\item Le fichier est d'abord compilé, et certaines de ses dépendances seornt
  déclarées comme étant les arguments du foncteur;
\item La functor unit compilée précédemment peut ensuite être appliquée sur des
  arguments pour obtenir une version instanciée.
\end{itemize}

Par exemple, supposons le fichier \texttt{mod.ml} suivant :
\begin{OCaml}
(* mod.ml *)
type t = Sign.t option

let create i = Some (Sign.create i)
let print = function
  | None -> print_endline ``No value''
  | Some v -> print_endline (Sign.to_string v)
\end{OCaml}

Ce fichier contient entre autres une dépendances vers un module
\texttt{Sign}. Celui-ci n'étant pas un module interne déclaré par le fichier, il
s'agit par conséquent d'un module externe, dont la signature est :
\begin{OCaml}
(* sign.mli *)
type t
val create: int -> t
val to_string: t -> string
\end{OCaml}

L'idée ici est de transformer automatiquement \texttt{mod.ml} en un foncteur qui
prendrait pour argument un module du type de \texttt{Sign}, c'est-à-dire :
\begin{OCaml}
(* mod.ml (representation interne) *)
(functor (Sign: module type of Sign) ->
  struct 
   ... (* code originel de mod.ml *)
  end
) 
\end{OCaml}
La compilation de \texttt{mod.ml} se fera de la manière suivante :
\begin{verbatim}
ocamlc -c -functor sign.cmi mod.ml
\end{verbatim}

Le but est donc d'avoir une unité de compilation qui est entièrement un
foncteur, et non pas qu'elle contienne un unique module qui soit le foncteur
(comme beaucoup de module existants, comme Map ou Set par exemple). Néanmoins,
\texttt{Mod} n'est pas utilisable tel quel puisqu'il n'existe aucun moyen de
représenter un tel module dans le système de type : une unité de compilation est
forcément une structure, par conséquent il n'est pas possible de l'utiliser de
la manière suivante :
\begin{OCaml}
module M = Mod(...)
\end{OCaml}
Ainsi la solution est de créer ce foncteur après le typage, au moment de générer
le \emph{lambda code} qui sera ensuite donné aux \emph{backend} du compilateur
pour être transformé soit en bytecode, soit en code natif. Par conséquent, pour
que \texttt{Mod} soit utilisable, il est nécessaire de de créer une application
de ce foncteur qui créera alors une unité de compilation standard.  Encore une
fois, ce foncteur n'existe pas au niveau de la signature du module, le seul
moyen est de laisser le compilateur se charger de l'application.

Supposons par exemple que l'on souhaite appliquer \texttt{Mod} sur le module
\texttt{impl.ml} suivant :
\begin{OCaml}
(* impl.ml *)
type t = { value : int }

let create value = { value }
let to_string v = string_of_int v.value
\end{OCaml}

La signature de \texttt{Impl} est compatible avec celle de \texttt{Sign}, il est
donc possible de l'utiliser comme argument. Ce que va alors créer le compilateur
est une version de \texttt{Mod} appliquée sur \texttt{Impl}, dont la
représentation interne serait en quelques sorte :
\begin{OCaml}
include Mod(Impl)
\end{OCaml}

Ainsi, la compilation se ferait de la manière suivante :
\begin{verbatim}
ocamlc -c -apply impl.cmi mod.cmo
\end{verbatim}
Néanmoins, le module instancié ainsi créé aura le même nom que que le foncteur,
par conséquent ils ne pourront cohabiter dans un même programme : la solution
sera d'utiliser un namespace pour les différencier. Ainsi, plusieurs solutions
sont possibles :
\begin{enumerate}
\item Donner le namespace de la version appliquée avec une option ``-ns''
\item utiliser le namespace des arguments donnés pour l'application, ce
  qui restreint à ce que tous les arguments appartiennent au même namespace et
  qu'il soit différent de celui de la \emph{functor unit}.  
\end{enumerate}

La seconde solution peut paraitre restrictive, mais elle est en réalité
logique. En effet, supposons par exemple que l'on souhaite donner comme argument
pour l'application un module de la Stdlib, au hasard \texttt{String}. Sa
signature ne peut pas être directement coercée vers celle de \texttt{Sign},
puisqu'il n'existe pas de valeur \lstinline{to_string} de type 
\lstinline{t -> string} (et la fonction \lstinline{create} n'a pas exactement le
comportement voulu, puisqu'ici le principe est de créer des valeurs de type
\texttt{t} pour encapsuler des entiers). La solution est donc de créer un module
intermédiaire qui depuis \texttt{String} créera ces valeurs :
\begin{OCaml}
(* string.ml *)
in namespace MyNamespace

type t = string
let create = string_of_int
let to_string (s : t) = s
\end{OCaml}

Généralement, un module ne sera pas directement applicable, ou bien c'est qu'il
a été écrit dans l'optique de convenir à cette signature précise (ou qu'il
s'agit d'une signature relativement standard, comme \texttt{OrderedType} utilisé
notamment par Map et Set de la bibliothèque standard). De ce fait, la plupart du
temps il sera nécessaire d'écrire un module avec une signature compatible, et
par conséquent le déclarer (ou non) dans un namespace. Au final, cette solution
a été retenue dans le prototype actuel, mais pourrait être changée sans
problème.

\medskip

Néanmoins, c'est solution n'est pas entièrement satisfaisante. En effet, il est
tout à fait possible d'écrire des namespaces dont tous les modules sont des
functor units, qu'il faudra ensuite appliquer pour obtenir un nouveau namespace
qui serait en quelque sorte l'instanciation du premier. Le problème à résoudre
est la gestion des dépendances entre ces modules. En effet, si on reprend
l'exemple précédent, et qu'on souhaite créer un fichier \texttt{list.ml} qui
utilise directement \texttt{mod.ml} (la version functorisée donc), le seul moyen
que celui-ci puisse l'utiliser est d'être capable de lui donner un argument. Par
exemple, si \texttt{Mod} contenait simplement un module \texttt{Make} qui
contienne tout son code, alors \texttt{list.ml} devrait être de la forme :
\begin{OCaml}
(* list.ml *)
module Make(Sign: module type of Sign) =
  struct
    module Mod = Mod.Make(Sign)
    type t = Mod.t list
    let print_all l = List.iter Mod.print l
  end
\end{OCaml}

Le module \texttt{List} contiendrait lui aussi un foncteur qui appliquerait
\texttt{Mod}. Donc par conséquent, \texttt{List} dans notre optique serait aussi
une unité functorisée, dont la représentation interne serait :
\begin{OCaml}
(* list.ml (representation interne) *)
(functor (Sign: module type of Sign) ->
  struct
    module Mod = Mod(Sign)
    type t = Mod.t list
    let print_all l = List.iter Mod.print l
  end)
\end{OCaml}
Mais cette représentation n'est pas efficace, pour plusieurs raisons :
\begin{itemize}
\item Si on souhaite utiliser conjointement \texttt{Mod} et \texttt{List},
  \texttt{Mod} sera instanciée une première fois par le compilateur à l'aide de
  \texttt{-apply} et une seconde fois dans \texttt{List}.
\item Puisqu'il s'agira de deux instances différentes, elles ne partageront pas
  leurs références et le code d'initialisation sera répété deux fois ce qui
  pourrait avoir des conséquences dramatiques, malgré qu'elles soient
  ``identiques'' du point de vue du système de types.
\end{itemize}
Par conséquent, il faut que \texttt{List} soit capable d'utiliser une version
déjà instanciée de \texttt{Mod} pour être efficace, l'astuce est alors de la donner
comme argument de foncteur à \texttt{List} :
\begin{OCaml}
(* list.ml ``(representation interne)'' *)
(functor (Sign: ...) (Mod: module type of Mod(Sign)) ->
   ...
)
\end{OCaml}
Evidemment, \lstinline{module type of Mod(Sign)} n'est pas exprimable dans le
système de type, mais donne l'idée générale du type de l'argument : il s'agit
d'un module qui est l'application de Mod sur Sign. Ainsi la gestion des
dépendances se fait de la manière suivante :
\begin{itemize}
\item Une functor unit peut dépendre d'autres functor units dans son namespace
  si leurs arguments sont les mêmes, et donc dépendre d'une functor unit
  implique d'être aussi functorisé. Une functor unit peut évidemment avoir une
  dépendance qui elle même n'est pas functorisée puisqu'il n'y a pas de soucis
  d'instanciation multiple.
\item L'application d'une functor unit n'est possible que s'il existe une
  version appliquée de ses dépendances (puisqu'il s'agit de ses arguments
  de foncteur).
\end{itemize}

Finalement, cette solution permet d'avoir un ensemble de modules functorisés sur
les mêmes arguments, et dont les dépendances sont gérées par le compilateur pour
éviter de multiples instanciations. Cependant cette solution nécessite de mettre
en place un système de build pour réaliser ces instanciations de manière
efficace. De plus, il n'est pas possible de currifier les foncteurs en l'état
actuel, bien que cela serait possible. Par conséquent, il pourrait également
être intéressant de lever la restriction sur les dépendances : une functor unit
peut être dépendantes d'autres à partir du moment où leurs arguments sont un
sous-ensemble des siens.

\medskip

Un prototype est disponible à l'adresse suivante
(\texttt{github.com/pcouderc/ocaml_namespace}, et avec un jeu de test et
d'exemples.

\chapter{Contexte de travail et analyse}

Ce court chapitre revient sur le contexte de travail durant le stage, les
différentes expérimentations et les difficultés à appréhender qui ont abouti à
la solution précédemment citée.

\section{Implémentation de namespaces}

Le premier problème, outre comprendre l'intérêt d'un mécanisme de namespaces,
est de comprendre l'architecture du compilateur. Dans notre cas, il s'agit de
comprendre comment se fait l'ajout d'identifiants dans l'environnement de
compilation. L'un des problèmes majeurs est que celui-ci est très peu documenté,
et par conséquent peut-être difficile à appréhender. En particulier, il faut
comprendre quels sont les mécanismes qui permettront de lier deux unités de
compilation de même nom et d'être capable de les différencier.

Pour ce faire, il était nécessaire de modifier le format de ces unités pour y
rajouter l'information de namespaces mais aussi spécifier le namespace de
chacune des unités importées. Cela n'était néanmoins pas suffisant, puisqu'il
fallait modifier le format des symboles générés par le compilateur pour intégrer
cette information. Cela peut paraitre simple, mais le compilateur nécessite un
certains nombre de changements pour notamment propager les informations de
namespaces, mais aussi de calculer l'ensemble des modules importés dans l'entête
de fichier, qui se fait en plusieurs passes pour chacun des namespaces utilisés : 
\begin{itemize}
\item Les modules importés explicitement (aliasés ou non) sont récupérés;
\item Le reste des modules (s'il y a un \texttt{\_} dans la contrainte) sont
  cherchés dans l'ensemble des unités accessibles au compilateur (dans les
  sous-dossiers correspondant au namespace);
\item Finalement, tous les modules cachés (\lstinline{as _}) sont enlevés.
\end{itemize}

Chacun des modules importés doit ensuite être ajouté dans l'environnement en
tant qu'alias (car le namespace n'est pas exprimable dans le
langage). L'environnement est alors modifié pour prendre en compte cette
nouvelle information.

Au final, plusieurs implémentations ont été essayée, jusqu'à arriver à la
version actuelle :
\begin{enumerate}
\item Créer explicitement dans l'arbre de syntaxe abstraite des alias de modules
  (où ces alias peuvent déclarer un namespace, ce qui n'est pas exprimable dans
  la syntaxe).
\item Pour chacun des namespaces, on crée une structure (et des sous-structures
  pour les sous-namespace, etc). De cette manière, il devient possible
  d'utiliser un namespace comme un module de première classe (en argument de
  foncteur).
\item Ne plus modifier l'AST pour directement ajouter les informations dans
  l'environnement.
\end{enumerate}
Le deux premières solutions étaient les plus simples à mettre en place : le
typeur s'occupait de rajouter toutes les informations dans l'environnement et de
générer les bons identifiants et chemins. La seconde notamment aurait pu
permettre plus d'expressivité, mais aurait posé problème lors de l'importation
de tous les modules d'un namespace, puisqu'il est difficile de savoir quels sont
les modules qui seront ajoutés dans la structure pour
l'utilisateur. Néanmoins, ces deux solutions n'étaient pas efficaces
puisqu'elles créaient explicitement des alias qui étaient exportés et donc
auraient causé des conflits. La troisième solution corrige ce problème car
seulement l'environnement est modifié et les alias non exportés.

Néanmoins, la seconde solution a un véritable intérêt puisqu'elle permet de
manipuler les namespaces comme des modules, et il serait intéressant de voir
dans quelle mesure il serait possible d'améliorer leur utilisation. Par exemple,
on pourrait introduire un nouveau \emph{kind} pour ces structures, qui
permettrait alors de les différencier et introduire de nouveaux comportements à
l'utilisation (par exemple des restrictions particulières).

\section{Réflexions sur la solution finale}

Les namespaces qui sont proposés ici n'ajoutent rien au langage actuel, le gain
en expressivité n'est pas important, mais l'intérêt se joue particulièrement au
niveau du confort à l'utilisation qu'ils apportent. Le développeur n'a plus à
définir des noms long pour éviter des conflits, l'utilisateur peut décider plus
finement quels modules importer dans son environnement de compilation et lui
évite d'utiliser les noms longs. De plus, ils ne nécessitent pas l'utilisation
d'un outil de compilation de projet particulier comme \emph{Ocamlbuild, OMake,
  ocp-build, Jenga, etc.}. De plus, leur utilisation permet de calculer plus
efficacement les dépendances pour \emph{ocamldep} par exemple : l'outil est donc
capable de donner de meilleures dépendances puisqu'il sait où se trouve chacun
des modules donné dans l'en-tête, et peut se permettre de lire les premiers
tokens des possibles dépendances pour vérifier qu'ils appartiennent au namespace
recherché. De plus, cette solution résout un problème rencontré lors de
l'utilisation de packs de modules ou de modules d'alias : si l'un des modules
aliasé ou packagé est modifié, alors le module d'alias (ou le pack) doit être
recompilé, et ainsi chacun des modules qui en dépend doit également être
recompilé. Ce goulot d'étranglement peut être évité depuis la 4.02 grâce à la
technique décrite précédemment puisque le module d'alias peut être compilé avant
ceux qu'il référence et donc ne pas avoir de dépendances vers ces
derniers. Néanmoins, cette technique est loin d'être standard et
intuitive. L'intégration de namespaces, qui sont ni plus ni moins que des noms
longs, permet d'éviter ces recompilations inutiles.

L'intérêt d'utiliser un \emph{en-tête} permet de dissocier le mécanisme de
déclaration et d'import du reste du langage. D'autres langages utilisent le
mot-clé \emph{import} pour faire référence à l'introduction de classes ou
valeurs depuis d'autres packages dans l'environnement courant, néanmoins cela
nécessiterait d'ajouter un nouveau mot-clé au langage (en plus de
\texttt{namespace}), ce qui explique alors le choix de 
\lstinline{with ... and  ...}. 
Cela n'est bien évidemment pas un problème au niveau de
l'implémentation, mais plutôt à l'utilisation. OCaml est un langage relativement
vieux et pratiquement tous les programmes écrits pour des versions antérieures
seront toujours compilables avec la version actuelle. Ajouter un mot-clé
peut-être dangereux car celui-ci peut être utilisé comme nom de variable dans
l'un de ces programmes et par conséquent n'être plus compilable. Bien
évidemment, modifier le nom d'une variable n'est pas vraiment un problème, mais
cela est à prendre en considération, et explique pourquoi ce choix de mot-clés
qui sont déjà utilisés dans le langage \footnote{\emph{import} est notamment un
  nom de variable utilisé à plusieurs reprise dans le compilateur.}.

Leur intérêt se situe particulièrement sur la manière dont peuvent être décrites
les bibliothèques, comment celles-ci sont installées et l'espoir de
standardisation dans l'organisation des bibliothèques du langage. En effet,
cette solution pourrait permettre de ne plus être obligé d'utiliser des outils
tel que \emph{ocamlfind} pour des programmes très simples : le compilateur sait
exactement quels modules utiliser si une option comme \texttt{-lib} proposée
précédemment était implémentée. %% En revanche, le compilateur ne peut créer
%% lui-même les dossiers correspondant aux namespaces sur le système de fichiers :
%% cela entrainerait une dépendance vers le module \emph{Unix} et donc entamerait
%% la portabilité du compilateur, celle-ci étant déjà précaire. Néanmoins, ce
%% défaut n'en est pas vraiment un :
%% \begin{itemize}
%% \item Un utilisateur n'utilisera pas de namespaces pour des programmes simples,
%%   leur utilité est vraiment de dissocier des ensembles de modules.
%% \item Il est possible de retrouver deux modules avec le même nom dans deux
%%   namespaces différents et de les utiliser conjointement. Le seul moyen d'avoir
%%   les deux fichiers sources est donc de les dissocier à l'aide de dossier. Il
%%   est possible de leur donner un nom différent et de les renommer à la
%%   compilation à l'aide de \texttt{-o}, mais cette fonctionnalité n'a pas de sens
%%   et n'aide pas à la relecture du programme ou de la bibliothèque.
%% \end{itemize}

L'implémentation actuelle modifie légèrement le type des alias de modules
(introduit dans la verson 4.02) : le type qui à l'origine contient le chemin
vers l'unité aliasée (ou le module) contient également le namespace d'où
provient le module. Cette information n'est utilisée qu'à la normalisation des
chemins pour justement substituer les alias par le veritable chemin, et par
conséquent ne modifie pas la sémantique du langage et du système de types.
En interne, les symboles sont légèrement modifiés pour devenir des noms longs de
la forme \texttt{<namespace>@<module>}, ce qui permet donc de différencier des
unités de compilation de même nom mais de provenance différente. Ces symboles ne
sont bien sûr pas reconnu par le langage et une telle syntaxe n'est donc pas
parsable. De ce fait, il est nécessaire de realiaser les expressions lorsque le
\emph{.mli} est inféré à l'aide de l'option \texttt{-i} du compilateur.

Utiliser un namespace n'est bien évidemment pas une obligation, et tout
programme compilable à l'aide de la version 4.02 l'est avec le compilateur
patché pour les namespaces.

L'intérêt également de cette approche est qu'elle permet de mieux comprendre
l'architecture d'un programme. En effet, il est parfois difficile de relire un
code qui utilise plusieurs bibliothèques en même temps. L'utilisation de
l'en-tête permet de connaître la provenance des modules, mais également d'aider
un utilisateur externe à compiler le programme dans le cas où la chaîne de
compilation n'est pas disponible.

Au final, cette solution satisfait l'ensemble des contraintes imposées dans la
problématique.

\section{Big functors}

L'ajout de namespaces functorisés est basé sur le travail de Fabrice Le Fessant
\cite{lefessant-bigfunctors} et reprend en grande partie la technique qui était
alors utilisée. La difficulté ici était de comprendre un travail qui a été
effectué précédemment sur une version plus ancienne du compilateur dont il
faudrait adapter le code et voire le modifier. En effet, toute la partie qui
permet de compiler en une functor unit est présent dans le patch, mais la
seconde partie (l'application) est un peu plus expérimentale.

En plus de devoir comprendre le fonctionnement du code, un autre intérêt est de
pouvoir manipuler le langage intermédiaire du compilateur (en surface du moins)
et réadapter certains algorithmes qui ne fonctionnaient plus à cause
d'optimisations qui interviennent désormais plus tôt dans le processus de
compilation.

\paragraph{Analyse de la solution}

En vérité, l'analyse de la solution apportée s'est faite dans le chapitre
précédent pour permettre de comprendre les choix qui ont été faits pour
l'implémentation et les restrictions apportées aux functor units.

En revanche, la solution présentée ici est véritablement expérimentale et vouée
à changer. Il serait intéressant de l'étendre à plusieurs namespaces, avoir
peut-être une syntaxe dans le langage mais également de revoir certaines
restrictions (qui sont finalement des détails d'implémentation, bien qu'ils
soient chaque fois justifiés) pour permettre plus de flexibilité.

\chapter{Exemples et cas d'utilisation}

\section{Namespaces simples}

\subsection{Namespaces hiérarchiques et installation}

La proposition de namespaces actuelles permet par exemple de définir de manière
simple une bibliothèque : en effet, l'utilisation de namespaces permet de ranger
des modules sous un même nom et est ainsi un moyen naturel de décrire, installer
et utiliser des bibliothèques. De plus, ces namespaces étant hiérarchiques, il
est possible de définir des sous-namespaces pour spécifier des comportements dans
une bibliothèque (une organisation où chaque sous-namespace répond à un besoin
spécifique de la bibliothèque).

Par exemple, une implémentation pour la bibliothèque standard pourrait être la
suivante (on ne prendra que quelques exemples) :
\begin{OCaml}
(* stdlib/list.ml *)
in namespace Stdlib
...
\end{OCaml}

\begin{OCaml}
(* stdlib/unsafe/obj.ml *)
in namespace Stdlib.Unsafe
...
\end{OCaml}

\begin{OCaml}
(* stdlib/internals/camlinternalFormat.ml *)
in namespace Stdlib.Internals
...
\end{OCaml}

Ce que l'on peut constater est qu'il devient alors très facile de déclarer des
bibliothèques. Ainsi, il serait envisageable de rendre le compilateur plus
efficace : puisque l'arborescence des namespaces correspond à l'arborescence du
système de fichiers, le compilateur pourrait être capable dans ce cas de
retrouver simplement les \emph{.cmo ou .cmx} comme il le fait déjà pour les
\emph{.cmis}. De cettte manière, la compilation d'un programme serait simplifiée
lorsqu'il s'agit d'utiliser une bibliothèque externe et ne demanderait donc plus
un système de \emph{build} complet. On pourrait par exemple imaginer un
\texttt{-lib} qui prendrait un nom de dossier en argument et s'occuperait alors
de lire les namespaces et unités de compilation depuis un répertoire
d'installation standard. Avoir un répertoire standard est envisageable grâce à
OPAM qui est devenu le système de gestion de paquets le plus utilisé au sein de
la communauté OCaml. On pourrait ainsi utiliser le compilateur comme le ferait
\emph{ocamlfind} qui s'occupe de donner les arguments nécessaire à la compilation.

Cette proposition de namespace vise ainsi à standardiser la manière dont sont
installées les bibliothèques externes.

\subsection{Extension et redéfinition de namespaces}

Par essence, les namespaces ne sont pas fermés, au contraire des modules qui
une fois compilé ne peuvent être étendus. Il s'agit par ailleurs de l'une des
caractéristiques qui joue en la faveur de ne pas utiliser les modules pour
simuler les namespaces. Ainsi, il est possible d'ajouter des modules dans un
namespace, et donc par conséquent en redéfinir certains. Cela n'impacte en aucun
cas le namespace de base et ne modifie pas ses fichiers : ces redéfinitions et
extensions sont gérées selon l'ordre des unités de compilation données au moment
de l'édition des liens. Chaque bibliothèque s'installe dans un dossier à part,
l'arborescence des unités de compilation n'est pas commune à tous. En effet,
cela pourrait être particulièrement dangereux :
\begin{itemize}
\item Si une biliothèque redéfinit des modules d'un namespace, les unités de
  compilation déjà existantes seraient écrasées;
\item Dans ce cas, si l'utilisateur souhaite désinstaller l'ancienne
  bibliothèque, cela reviendrait à supprimer également les unités qui ont été
  ajoutées par la précédente.
\end{itemize}

Un exemple de redéfinition et d'extension serait :
\begin{OCaml}
(* stdlib/string.ml *)
(* Ce module remplacera le module String du namespace Stdlib *)
...
\end{OCaml}

\begin{OCaml}
(* stdlib/linkedlist.ml *)
(* Ce module implemente des listes chainees de maniere imperative, et donc non
   persistante *)
...
\end{OCaml}

Ainsi, il est possible dans le programme (en supposant que le namespace Stdlib
ne soit pas automatiquement importé) :

\begin{OCaml}
(* my_prog.ml *)
with Stdlib.(_)

type list = Linkedlist.t
\end{OCaml}

\subsection{Utilisation d'unités de compilation de même nom}

Dans l'état actuel de la communauté OCaml, il existe plusieurs libraries dont le
but est de définir une nouvelle bibliothèque standard : on notera notamment Core
et Batteries. Ces dernières utilisent les techniques citées précédemment pour
éviter les conflits : Core utilise un module \texttt{Core} qui est un ensemble
d'alias vers d'autres modules tous préfixés par \texttt{Core_} et Batteries
préfixe tous ses modules par \texttt{Bat_}. De cette manière, il est possible
d'utiliser ces deux biliothèques avec la \texttt{Stdlib} sans avoir de
conflit. Si on supposait que celles-ci étaient réécrites avec des namespaces, il
serait possible de les utiliser conjointement dans un programme. Ce n'est pas un
comportement voulu, mais cela peut avoir une utilité pour réaliser des
benchmarks ou des tests sur des algorithmes.

Par exemple, un programme qui ferait des benchmarks sur les implémentations de
\texttt{Hashtbl} de chacune :
\begin{OCaml}
with Stdlib.(Hashtbl)
and Core.(Hashtbl as CHtbl)
and Batteries.(Hashtbl as BHtbl)

...
let _ =
  let h1 = Hashtbl.create 17 in
  let h2 = CHtbl.create 17 in
  let h3 = BHtbl.create 17 in
  (* une batterie de tests et de comparaison de chacune des operations *)
\end{OCaml}


\section{Utilisation des functor units}

\subsection{Cas d'utilisation}

Supposons que l'on écrive une biliothèque pour écrire des serveurs web. En
particulier, un serveur doit pouvoir gérer plusieurs requètes en même temps, et
nécessite donc d'être capable de paralléliser celles-ci. On peut par exemple
prendre le cas de \emph{CoHTTP}, qui utilise \emph{Lwt} ou \emph{Async}, deux
bibliothèques écrites sous forme monadiques, pour la partie concurrence du
traitement des requètes. Si un seul module est dépendant de l'implémentation de
la monade concurrente, un simple foncteur est suffisant. En revanche, si
l'ensemble de la bibliothèque dépend de cette implémentation, la seule solution
est d'avoir un fichier de base qui \emph{bind} l'une ou l'autre des
implémentations au moment de la configuration de l'environnement (donc avant la
compilation). En effet, utiliser un foncteur pour ce fichier de bindings n'est
pas envisageable : le foncteur devrait donc être appliqué dans chaque module qui
l'utilise, et le code d'initialisation (s'il y en a) serait exécuté à chaque
fois.

La solution des functor units permet à l'ensemble de la bibliothèque d'être
complètement abstraite sur l'interface de cette monade, et donc par la suite de
créer un namespace qui serait l'instantiation de cette bibliothèque sur cette
monade. Voici un exemple concret :

\begin{OCaml}
(* cohttp/asyncMonad.mli *)
in namespace Cohttp

type 'a t

val (>>=) : 'a t -> ('a -> 'b t) -> 'b t

val return : 'a -> 'a t
val bind : 'a t -> ('a -> 'b t) -> 'b t (* == (>>=) *)
val poll : 'a t -> 'a option
...
\end{OCaml}

\begin{OCaml}
(* cohttp/requestHandler.ml *)
in namespace Cohttp
...
let M = AsyncMonad
...
\end{OCaml}

\begin{OCaml}
(* cohttp/protocol.ml *)
in namespace Cohttp
...
open RequestHandler
\end{OCaml}

Le namespace Cohttp contient donc le code générique pour un serveur HTTP (on
supposera que ces deux modules sont suffisant, il ne s'agit pas d'un exemple de
la véritable bibliothèque Cohttp). La compilation de ces modules serait :
\begin{verbatim}
ocamlc -c cohttp/asyncMonad.mli
ocamlc -c -functor cohttp/asyncMonad.cmi cohttp/requestHandler.ml
ocamlc -c -functor cohttp/asyncMonad.cmi cohttp/protocol.ml
\end{verbatim}

Dans cet exemple, le module Protocol ne fait jamais explicitement référence à
AsyncMonad, néanmoins pour pouvoir utiliser RequestHandler il doit être
functorisé sur les mêmes arguments que lui.

On souhaite ensuite instancier une version de la bibliothèque sur Lwt. On crée
donc un nouveau namespace Cohttp.Lwt, et un fichier qui bind le module Lwt dans
ce namespace. On suppose que Lwt appartient au namespace Ocsigen :
\begin{OCaml}
(* cohttp/lwt/monad.ml *)
in namespace Cohttp.Lwt
with Ocsigen.(Lwt)

type 'a t = 'a Lwt.t

let (>>=) = Lwt.(>>=)
let return = Lwt.return
let bind = Lwt.bind
let poll = Lwt.poll
...
\end{OCaml} 

Il est désormais possible d'instancier la bibliothèque sur cette monade :

\begin{verbatim}
ocamlc -c cohttp/lwt/monad.ml
ocamlc -c -apply cohttp/lwt/monad.cmo cohttp/requestHandler.cmo
ocamlc -c -apply cohttp/lwt/monad.cmo cohttp/protocol.cmo
\end{verbatim}

Si finalement on écrit un serveur très simple à l'aide de Cohttp.Lwt :
\begin{OCaml}
(* my_server.ml *)
with Cohttp.Lwt.(Protocol)

...
\end{OCaml}

La compilation sera alors :

\begin{verbatim}
ocamlc -o server cohttp/requestHandler.cmo cohttp/protocol.cmo \
    cohttp/lwt/monad.ml cohttp/lwt/requestHandler.cmo cohttp/lwt/protocol.cmo \
    my_server.ml 
\end{verbatim}

On remarque que la ligne de compilation parait très longue, mais cela se
justifie du fait que les versions instanciées sont toujours dépendantes des
functor units qu'elles instancient : tout le code se trouve dans ces functor
units, les instances ne font qu'appliquer les arguments.

%% \subsection{Réflexion sur l'implémentation et le choix des functor units}

%% La solution pour avoir des namespaces functorizée est moins élégante que celle
%% des namespaces : en effet, ici tout se passe du côté de la chaîne de compilation
%% et nécessite de mettre en place un système de build ou d'utiliser un outil
%% capable de comprendre et gérer ces functor units et leur instantiation. L'un des
%% objectifs n'est pas atteint. Néanmoins, le gain en expressivité est réel,
%% puisqu'il devient possible de définir des bibliothèques génériques.

%% Certaines restrictions pourraient être levées ou du moins allégées dans une
%% possible mise-à-jour:
%% \begin{itemize}
%% \item Le fait que le module sur lequel est appliquée la functor unit pourrait ne
%%   pas appartenir au même namespace (on pourrait utiliser Lwt directement), mais
%%   se justifie car il est rare que l'interface du module que l'on souhaite
%%   utiliser lors de l'instantiation ait une interface directement compatible. Le
%%   plus souvent, il faudra écrire un module qui \emph{bind} l'argument vers la
%%   bonne interface.
%% \item Dans la version actuelle, la currification n'est pas possible. Ce n'est
%%   que par soucis de simplicité et cela serait réalisable.
%% \item En terme de dépendances, dans les big functors deux unités sont
%%   compatibles si les arguments de la dépendances sont un sous-ensemble des
%%   arguments de l'unité en cours de compilation. Cela devrait être également
%%   possible dans l'implémentation actuelle.
%% \end{itemize}

%% Sans functor-units il serait possible de créer des bibliothèques ayant le même
%% comportement. Il suffirait que le code de chaque module doit contenu dans un
%% foncteur, et que chacunes des dépendances soient explicitement instanciées en
%% utilisant l'argument de ce foncteur. Néanmoins, cette solution a plusieurs
%% défauts :
%% \begin{itemize}
%% \item Pour pouvoir utiliser un module, il faut à chaque fois l'instancier. Cela
%%   n'est pas tellement un problème du point de vue des types puisque les
%%   foncteurs d'OCaml sont applicatifs, et par conséquent deux instances de
%%   foncteurs sont identiques du point de vue des types si leur argument est le
%%   même. En revanche, l'application du foncteur a un coup non négligeable, et si
%%   code d'initialisation il y a celui-ci est executé à chaque fois. De la même
%%   manière, tout effet de bord ou référence sera propre à chaque instance et non
%%   pas partagé entre celles-ci malgré qu'elles soient identiques du point de vue
%%   du système de types.
%% \item Le module pourrait être instancié une seule fois et inclus dans un nouveau
%%   module :
%% \begin{OCaml}
%% (* protocol_lwt.ml *)
%% module M = Protocol.Make(Lwt)
%% include M
%% \end{OCaml}
%% Néanmoins, dans cette solution les dépendances sont appliquées à chaque fois, le
%% compilateur est incapable de détecter qu'il y a déjà eu application. Au
%% contraire, l'application d'une functor units nécessite que ses dépendances qui
%% sont functorisées sur les mêmes arguments existe dans le même namespace pour
%% pouvoir \texttt{explicitement} les utiliser. 
%% \end{itemize}

%% Par conséquent, cette solution peut être imitée dans le langage actuel avec la
%% restriction de ne pas avoir d'effets de bords (donc pas de code
%% d'initialisation) et de code mutable, et avec la contrainte que le foncteur sera
%% chaque fois appliqué (que soit directement ou indirectement), même s'il existe
%% déjà une instance de celui-ci appliqué sur le même argument.

\chapter{Conclusion et perspective}

La problématique des namespaces est un sujet intéressant : il s'agit d'abord
d'un sujet de discussion récurrent au sein de la communauté, avec de nombreuses
idées mais sans jamais aucun accord entre les participants. Bien qu'ils n'apportent
pas un gain évident en expressivité, ils permettent plus de confort pour le
développeur et l'utilisateur. Les namespaces sont un excellent moyen de décrire
une bibliothèque dans le langage, mais aussi d'apporter un standard dans la
manière dont sont installées celles-ci sur le système de fichiers, et permet
également de simplifier le travail du compilateur sans nécessiter d'outils
externes (le moins possible en tout cas). L'intérêt de notre approche est
qu'elle ne modifie pas un système de types déjà compliqué et ainsi ne demande
pas de vérifier et prouver la sûreté et la complétude de la solution, et donc
qu'elle ne change pas la sémantique actuelle du langage.

L'idée d'avoir un moyen de déclarer des namespaces génériques est intéressante
et logique dans le contexte de la programmation fonctionnelle où le code d'un
programme est facilement réutilisable grâce aux fonctions d'ordre supérieur. La
solution demande un peu d'effort au niveau de la chaîne de compilation
néanmoins, et n'est pas aussi simple que celle des namespaces. La solution de
namespaces proposée ici se rapproche en particulier de la mécanique des packages
de Java ou Scala, avec la généricité des packages de Backpack.

Le but de ce stage est de réouvrir la discussion sur le besoin de namespaces,
mais en apportant cette fois une solution concrète et non seulement des
idées. L'espoir est donc de faire converger la communauté vers une solution
définitive. Le prototype permet notamment aux différents acteurs de se faire une
idée sur notre proposition. Cette proposition sera d'ailleurs présentée durant
l'ICFP 2014, à l'OCaml Users and Developpers Workshop le 5 septembre.

Par la suite, il est évident que si cette solution plait il deviendra nécessaire
de continuer à travailler sur ce prototype, que ce soit en terme de nettoyage du
code, de refactorisation mais surtout pour modifier ou ajouter certaines
fonctionnalités dans le but de pouvoir intégrer cette mécanique au langage. En
ce sens, il pourrait être intéressant par la suite de pouvoir accéder à des
modules directement dans le programme sans import préalable. Pour cela, il
faudra définir une syntaxe claire et modifier légèrement le système de types
pour prendre en compte ces nouvelles informations.

De même, les namespaces importés en tant que structures sont pour le moment
compilés relativement naïvement, en ajoutant dans l'AST directement les
modules. Cela peut avoir une conséquence fâcheuse dans le sens où ceux-ci seront
alors exportés à l'extérieur de l'unité de compilation. Une solution serait de
faire directement une substitution au moment du typage, remplacer le chemin par
la structure directement. De plus, il pourrait être intéressant d'étendre le
mécanisme d'ouverture automatique de modules à des ensembles de modules. Par
exemple, au lieu d'avoir simplement un module Pervasives utiliser des namespaces
ayant pour nom Pervasives. Néanmoins, cette extension demandera plus de travail,
notamment car il peut-être difficile de gérer l'ordre d'ouverture.

De plus, il serait intéressant de lever certaines restrictions sur les functor
units. En l'état actuel il n'y a pas de currification, mais cela ne devrait pas
être particulièrement difficile à ajouter. De plus, on pourrait supposer que les
dépendances puissent être functorisées sur un sous-ensemble des argument de
l'unité en cours de compilation.

Une autre idée qui serait intéressante serait d'avoir la capacité pour le
compilateur de compiler un programme en lui donnant simplement le fichier
d'entrée, comme le ferait \emph{ocamlbuild}. Cela serait possible grâce à la
correspondance entre les namespaces et le système de fichiers et la
simplification du calcul des dépendances. Dans cette optique, il serait
également intéressant de modifier les systèmes de builds actuels pour qu'ils
utilisent les namespaces et les functor units. Un langage de description de
programme comme celui d'\emph{ocp-build} pourrait permettre de facilement
déclarer des unités functorisées et leurs applications.

\bibliographystyle{acm}
\bibliography{biblio}
\addcontentsline{toc}{chapter}{Bibliographie}

\appendix

\chapter{Syntaxe d'un en-tête}
\label{header-bnf}

%% \begin{figure}
\begin{grammar}
<module_name> = <uident>

<longident> ::= <uident>
\alt <longident> `.' <uident>

<header> ::= <namespace_decl> <imports>
\alt <imports>

<namespace_decl> ::= `in' `namespace' <longident>

<imports> ::= <import> <imports> 

<import> ::= (`with'|`and') <ns_conf> 

<ns_conf> ::= <longident> `.' `(' <modules_constraints> `)'

<modules_constraints> ::= <module_constraint>
\alt <module_constraint> `,' <module_constraints>

<modules_constraint> ::= `_'
\alt <module_name> `as' <module_name>
\alt <module_name> `as' `_'
\alt <module_name>
\end{grammar}
%% \caption{Syntaxe d'un en-tête de fichier \texttt{.ml(i)}}
%% \end{figure}

\chapter{Formalisme simple de l'édition des liens avant et après 4.02}
\label{appendix-soa}

Cette annexe est tirée de la proposition de namespaces pour 4.02. Celle-ci est
découpée en deux parties : un état de l'art sur la manière de simuler les
namespaces avec des exemples et une formalisation relativement simplifiée du
mécanisme de l'édition des liens. Cette partie est intéressante notamment pour
expliquer comment l'ajout des alias de modules a changé l'édition des liens et
la gestion des dépendances pour pouvoir compiler un programme. Cette partie est
rédigée en anglais, puisqu'elle est directement tirée de la proposition.


\input{linking-form}

\chapter{Proposition originelle}

L'annexe qui suit est la version finale de la proposition de namespaces écrite
comme référence pour la communauté. Elle n'est pas forcément utile pour
comprendre ce rapport mais fait parti du travail effectué durant ce stage.

\input{proposal}

\end{document}
