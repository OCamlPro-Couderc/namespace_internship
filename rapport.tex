\documentclass[11pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{syntax}
\usepackage{cite}

\title{Proposition, formalisation et implémentation d'un mécanisme de namespaces
  pour OCaml}
\author{Pierrick COUDERC}

\setlength{\grammarindent}{8em} % increase separation between LHS/RHS 

\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      %% commentstyle=\color{purple},
                      %% stringstyle=\color{red},
                      %% identifierstyle=\ttfamily,
                      %% keywordstyle=\color{blue},
                      %% basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}

\begin{document}

\maketitle

\section*{Remerciements}

\tableofcontents

\chapter{Introduction}

Dans le monde des langages, il est souvent utile de pouvoir réutiliser des noms
de fonctions ou de valeurs à différents endroits d'un programme, notamment en
terme de lisibilité du code écrit, mais également pour l'utilisateur qui doit
utiliser ces fonctions. Si de tels moyens n'existaient pas, en d'autre terme
s'il n'existait aucune portée dans le langage, l'utilisateur se verrait
contraint d'écrire et d'imaginer des noms affreusement longs pour éviter de
potentiels conflits à la compilation et/ou à l'exécution de son
programme. Typiquement, si on suppose que deux structures de données,
\texttt{Map} et \texttt{Hashtbl}, pour lesquelles il existe des opérations
relativement identiques (créer, ajouter, retirer, itérer, etc), les noms des
fonctions seraient de l'ordre de \texttt{hashtbl\_add, hashtbl\_find} et
respectivement pour Map. Si maintenant quelqu'un voulait utiliser sa propre
implémentation de table de hashages, il se retrouverait à écrire des noms
suffisament longs pour éviter tout conflit.

En terme de passage à l'échelle, ce problème est évident : il devient
pratiquement impossible d'écrire un programme correct et lisible, notamment
parce qu'un programme mesure en général quelques milliers de lignes, mais aussi
parce que certains parties du code font appel à des bibliothèques externes dont
une partie des éléments sont abstraits. Ce problème est résolu notamment par ce
que l'on nomme un \textbf{espace de noms} (ou \texttt{namespace}).

Il existe de nombreux moyens de simuler des espaces de noms, par exemple à
l'aide de la portée lexicale ou syntaxique dans le programme : tout nom défini à
l'intérieur d'un bloc n'est visible que par lui et par conséquent, aucune
fonction ou valeur de même nom en dehors n'est plus atteignable, et ce qui est
déclaré dans le bloc n'est pas visible vers l'extérieur. Ce principe de portée
s'applique aussi bien aux blocs, aux fonctions mais aussi aux \emph{unités de
  compilation} (autrement dit, aux fichiers).

OCaml en particulier est un langage fonctionnel fortement typé et possédant
notamment un système de modules dont l'utilité est de pouvoir définir des
espaces de noms d'ordre supérieur : un module dans le système de type de ML est
une valeur comme une autre, et de ce fait il est possible d'utiliser un module
en paramètre de fonction et également d'avoir des applications de modules. Ces
applications, ou \emph{foncteurs}, permettent de définir des modules abstraits
sur une interface et donc une meilleure réutilisabilité du code. Un module peut
être déclaré à n'importe quel endroit du code, et une unité de compilation est
elle-même un module, à la différence près qu'elle ne peut être functorisée.

En revanche, malgré un système de modules fort, le passage à l'échelle peut
parfois être problématique : en terme d'architecture de programme, il n'est pas
rare de retrouver les mêmes noms d'unité de compilation entre deux
bibliothèques. Par exemple, une unité de compilation \texttt{Utils} est
généralement très utilisée pour les fonctions génériques qui sont utilisées par
tout le reste du code. De ce fait, il devient impossible de générer un programme
correct qui auraient des unités de même nom, et il incombe alors au developpeur
de préfixer ses modules pour éviter de probables conflits. Il devient dès lors
nécessaire de trouver une solution à ce problème pour permettre d'avoir d'autres
discriminants que le nom du module pour permettre une édition des liens
correcte. Autrement dit, il devient nécessaire d'avoir une notion d'espace de
noms pour les unité de compilation.

Ce stage a été réalisé au sein d'OCamlPro et sous la direction de Fabrice Le
Fessant.

\chapter{Etat de l'art}

\section{Unités de compilation}

Ce sujet de stage touche plusieurs domaines différents, mais particulièrement
celui de la compilation. Un programme est rarement constitué d'un seul fichier
mais plus généralement d'un ensemble de fichiers, appelés aussi \emph{unités de
  compilation}. Une unité de compilation possède généralement une interface et
une implémentation, la première étant une description sur la manière d'utiliser
la seconde. Il s'agit de l'interface d'entrée pour d'autres programmes pour
pouvoir utiliser cette unité de compilation. On parle alors de compilation
séparée \cite{Cardelli97programfragments}. 

Ainsi, un programme est un ensemble d'unité de compilation ordonnée selon leur
dépendance. Néanmoins, ces unités ne peuvent être liées entre elles qu'à la
condition qu'elles soient compatibles. Autrement dit, dès qu'une unité en
utilise une autre, donc qu'il s'agit d'une ses dépendances, elle doit être
recompilée si l'une de ses dépendances l'a été pour s'assurer de leur
compatibilité. Un programme est ainsi un ensemble d'équations à résoudre
pour pouvoir être correctement compilé \cite{Drossopoulou99afragment}. On
retrouve d'ailleurs une formalisation simplifiée d'un programme correct en terme
d'unités de compilation en annexe.

\section{Namespaces et packages}

Le principe de namespaces existe déjà dans plusieurs langages, on peut le
retrouver par exemple en C++\cite{cppspec} où il est possible de créer des
namespaces qui contiennent des valeurs, des classes ou des fonctions, et qui
peuvent être déclarés dans plusieurs unités différentes. Néanmoins, cette
solution ne correspond pas à celle vers laquelle nous nous dirigeons, à savoir
un mécanisme pour différencier des unités de compilation de même nom. En ce
sens, notre idée est à rapprocher fortement des packages de Java\cite{java-spec}
et en particulier Scala\cite{scalaspec}. En effet, dans ces deux langages les
packages permettent d'organiser des classes sous une hiérarchie et ainsi
d'utiliser de manière conjointes des classes de même nom en utilisant le chemin
complet. Néanmoins, ce choix se justifie dans ces deux langages puisque la
classe est l'unité de base le langage, il est donc nécessaire d'avoir ce
mécanisme de noms longs pour les différencier. En revanche, les clauses
d'importation de Scala permettent une meilleure expressivité en donnant la
possibilité d'importer plusieurs classes d'un package mais aussi en les aliasant
ou en les masquant dans le cas où tout le package est importé.

OCaml quand à lui possède déjà son système de modules\cite{Leroy00} qui fait
office de mécanisme de namespaces : les fonctions et valeurs peuvent être ainsi
préfixées d'un chemin, permettant alors de différencier celles-ci à l'exécution
et à la compilation. Néanmoins, deux unités de compilation ne peuvent coexister
dans un programme si celles-ci ont un même nom.

Finalement un travail récent a été fait autour d'Haskell pour résoudre notamment
le problème de compilation séparé\cite{KilpatrickDJM14} : en effet, le système
de modules d'Haskell ne possède pas de \emph{signatures}, et par conséquent
n'est pas capable de compiler de manière distribuer un programme. Une unité de
compilation n'est compilable qu'à partir du moment où toutes ses dépendances le
sont. Le résultat est un langage de packages au dessus d'Haskell, qui permet en
outre de \emph{typer-checker} un programme sans donner d'implémentation pour
chacune des dépendances grâce à des interfaces de modules, mais également un
système de packages pour distinguer les modules.

Finalement, il est important de s'intéresser aux nombreuses discussions de la
communauté\cite{ocaml-platform} et particulièrement aux différentes propositions
émises par certains mainteneurs du compilateur\cite{ocaml-proposals}, notamment
un langage formel de description d'environnement\cite{remy-scherer-prop} et
décrivant ainsi les possibilités attendues pour des namespaces. Jusqu'ici dans
le langage plusieurs solutions alternatives étaient disponibles pour palier au
manque de namespaces : les noms longs, les packs de modules et les modules
utilisés comme namespaces à l'aide d'alias. Des exemples concrets sont donnés à
la fois dans le chapitre suivant mais aussi en annexe \ref{appendix-soa}, où une
formalisation simplifiée est donnée pour exprimer ce que représente en terme de
dépendances et d'unités de compilation un programme correct. Cette annexe
présente les changements intervenus avec l'ajout des alias de modules et des
dépendances dites faibles. 

\chapter{Problématique}

Pour une meilleure compréhension de ce rapport, il est nécessaire de définir
certains termes qui seront mentionnés de manière régulières. Ainsi, un module
fera toujours référence à une unité de compilation et non un module déclaré dans
le fichier, sauf lorsque le contraire est indiqué : cette définition est logique
puisque la problématique étudiée ici se concentre sur les unités de compilation
uniquement. 

Dans l'implémentation actuelle d'OCaml, il est immpossible de lier deux unités
de compilation de même nom, ou du moins d'y référer de manière explicite. En
effet, lorsqu'un programme est compilé en \emph{bytecode}, le code
d'initialisation des deux modules sera bien executé, en revanche seul le module
lié en premier sera effectivement accessible. Dans le cas de compilation native
(en assembleur), l'éditeur de lien ne pourra lier les deux unités : puisque les
symboles générés seront les mêmes, le compilateur ne pourra générer un programme
qui sera correct.

La solution adoptée par l'ensemble des développeurs est de préfixer leurs
modules par le nom de la bibliothèque dont elle est issue. Cette solution est
efficace mais oblige l'utilisateur à devoir utiliser des noms parfois longs dans
son programme. Bien qu'il ne s'agisse que d'un problème en terme de praticité,
il peut être intéressant de proposer une solution plus générale à ce problème.

Dans ce sens, l'une des solutions utilisées par les développeurs est de créer
des \texttt{packs} de modules : il s'agit alors de plusieurs unités de
compilation regroupées au sein d'une seule qui fait alors office d'espace de
nom. Cette solution est déjà plus intéressante, car elle permet de distribuer
une bibliothèque sous la forme d'un seul objet, mais est également plsu souple à
l'utilisation. En effet, chaque module est donc accessible à l'aide du chemin
\texttt{<nom\_du\_pack>.<nom\_de\_l'unité>} : le compilateur transforme chacune
des unités du pack en sous-module. Ainsi, il suffit d'ouvrir \texttt{open} le
module qui fait office de pack pour utiliser les noms originaux. En revanche,
cette solution a plusieurs défauts :
\begin{itemize}
\item elle oblige à emporter \textbf{tous} les modules du pack, même si un seul
  est utilisé;
\item il est impossible d'avoir du code d'initialisation dans ce module-pack,
  par exemple pour y inclure des fonctions ou opérateurs utiles pour tous les
  modules du pack.
\end{itemize}
En résumé, il n'y a aucun contrôle sur le contenu effectif du pack, il n'est
possible que d'y ajouter des unités de compilation mais aucune autre opération
n'est possible.

Une autre solution adoptée par d'autres tels que Jane Street pour leur
bibliothèque \emph{Core} ou les développeurs de la bibliothèque \emph{Batteries
  Included} est d'utiliser un module d'alias. En d'autre termes, un module qui
est une suite d'alias d'autres modules, permettant ainsi d'avoir l'avantage du
pack mais sans le second inconvénient. En effet, puisque ce module est écrit par
le développeur et non plus généré automatiquement par le compilateur, il est
possible d'y include du code qui sera directement utilisable dès lors que ce
``module namespace'' sera ouvert. En revanche, avant la version 4.02 d'OCaml,
cette solution nécessitait tout de même de donner explicitement au compilateur
tous les modules référencés dans ce dernier.

La prochaine version du compilateur règle ce problème en rajoutant (entre
autres) une notion de dépendances faibles (ou transparentes comme son auteur,
Jacques Garrigues, les appelle). Ainsi il en résulte trois propriétés
intéressantes:
\begin{enumerate}
\item un alias se propage, i.e. il peut être instancié tardivement, dans une
  autre unité de compilation;
\item tant qu'un alias n'est pas utilisé, il n'est pas nécessaire à la
  compilation; 
\item son interface peut ne pas être présente au moment de la compilation du
  ``module namespace''.
\end{enumerate}
De plus, deux autres fonctionnalités ont été rajoutées:
\begin{itemize}
\item une option \texttt{-open} qui permet d'ouvrir un module avec même de
  commencer à typer le programme;
\item la sémantique du \texttt{-o} a été modifiée et permet désormais de choisir
  le nom interne de l'unité de compilation qui sera générée (jusque là,
  seulement le nom du fichier changeait, son nom de module était celui du
  \texttt{.ml}).
\end{itemize}

Ces traits permettent ainsi de simuler des namespaces, mais de manière non
intuitive, et demande de mettre en place un schéma de compilation relativement
compliqué. Un exemple simple serait le suivant:

Supposons que l'on écrive deux modules \texttt{set.ml} et \texttt{map.ml}, et
dont \texttt{Set} est dépendant de \texttt{Map}. On utilise un module
\texttt{lib.ml} qui fait office de ``module namespace''. Le contenu des trois
fichiers est le suivant:

\begin{OCaml}
(* map.ml *)
...

(* set.ml *)
...
module UnitMap = Map.Make(
  struct 
    type t = unit 
    let compare = compare 
  end)
..

(* lib.ml *)
module Map = Lib_map
module Set = Lib_set
\end{OCaml}

Le lecteur attentif remarquera que le nom dans \texttt{lib.ml} des deux modules
aliasé est différent de leur nom d'origine, et de plus, que \texttt{set.ml} fait
explicitement référence à \texttt{Map} (donc \texttt{map.ml}). L'astuce icic est
d'utiliser les fonctionnalités introduite précédemment :
\begin{enumerate}
\item \texttt{lib.ml} est d'abord compilé, mais comme ce module ne contient que
  des alias et d'après la propriété (2) des alias. On donne également l'option
  \texttt{-no-alias-deps} qui permet d'utiliser la proriété (1).
\item \texttt{map.ml} est compilé avec l'option \texttt{-o lib\_map.ml}.
\item \texttt{set.ml} est ensuite compilé à l'aide de les options \texttt{-o
  lib\_set.ml} et \texttt{-open Lib}.
\end{enumerate}

La dernière étape permet donc de simuler le namespace : la directive
\texttt{-open Lib} permet de propager de manière transparente les alias de Lib
dans \texttt{set.ml} et ainsi de ne pas avoir à utiliser le nom long
\texttt{Lib\_map} (et de ne pas écrire les noms de fichiers longs). Cette
technique peut paraître relativement complexe, mais a été avancée comme la
non-nécessité de devoir inclure un véritable mécanisme de namespaces dans le
langage. Elle nécessite un schéma de compilation relativement complexe, capable
de gérer de manière transparente les changements de noms de modules et les
dépendences qui semblent être mutuellement récursives. L'intérêt est seulement
le fait que les alias non utilisés n'auront pas à être liés à la compilation.

Cette solution n'est pas satisfaisante, tout d'abord à cause de cette
gymnastique non intuitive pour comprendre le schéma de compilation, mais
également parce qu'elle nécessite un véritable \emph{système de build} pour être
capable de l'utiliser. De plus, il manque une propriété importante que l'on
pourrait attendre des namespaces : l'extensibilité.

L'intérêt n'est pas seulement de proposer un mécanisme de namespaces simple,
mais également de trouver une solution aux \emph{big functors}, une version des
packs qui permettent d'englober les modules sous un foncteur et ainsi obtenir
un pack paramétrique, réutilisable avec des implémentations
différentes. 

\medskip

Au final, la problèmatique de ce stage est d'imaginer et prototyper un mécanisme
de \emph{namespaces} pour OCaml, dont l'utilisation soit simple et facilement
compréhensible, mais qui en plus de ça ne demande pas un schéma de compilation
particulier pour être efficace. De plus, l'idée est également de trouver une
solution pour les namespaces functorisés, qui permettrait de mettre en oeuvre
des bibliothèques totalement génériques et instantiées par l'utilisateur.


\chapter{Solution}

Dans le cadre d'un système efficace de namespaces, plusieurs solutions ont été
proposée et envisagées. Il faut savoir que ce sujet est étudié informellement
depuis déjà longtemps dans la communauté et plusieurs contributeurs ont proposé
une solution. En revanche, les solutions étant souvent éloignées et les avis
divergeants, aucun compromis n'a été établi vers une proposition qui pourrait
satisfaire le plus de monde. Le but est ici de trouver ce compromis mais en
proposant une solution concrète avec un prototype. L'intérêt est d'éviter de
relancer une discussion sur la manière dont doit être ajoutée cette
fonctionnalité, mais plutôt de discuter d'une solution effective et l'améliorer
en fonction des avis reçus.

En ce sens, il peut être intéressant de voir les grands axes qui ont été étudiés
pour des solutions à ces propositions et de quelle manière notre proposition
finale la rejette ou au contraire s'en inspire.

Les objectifs de notre solution sont les suivants :
\begin{itemize}
\item \^{E}tre consistant, en d'autres termes ne pas devoir jongler entre le
  langage et le \emph{build system};
\item Simplicité en terme de construction et d'utilisation;
\item Orthogonalité avec le système de types;
\item Pas de changement dans la sémantique du langage;
\item Etre compatible avec le schéma de compilation actuel, i.e. ne demande
  pas d'outils particuliers supplémentaires.
\end{itemize}

Dans chacune des propositions existantes, au moins un point n'était pas
respecté. Par exemple, l'une des solutions étaient d'étendre le nom des modules
avec un préfixe qui serait le nom du namespace :
\texttt{<namespace>-<module>.ml}. Cette solution relativement simple visait à ne
pas changer en profondeur le compilateur, mais semblait trop simple. Dans le
langage, pour la plupart des solutions, le chemin des modules était étendu avec
un namespace. Par exemple, l'utilisation d'une unité de compilation se faisait
de la manière suivante :
\texttt{Chemin\#Du\#Namespace\#Module.Sous\_module}. 

Une solution était également d'ajouter un nouveau type de fichier de description
de namespaces, mais cette solution n'apportait finalement pas la simplicité
désirée. Finalement, durant la synthèse des différente solution émergeait un
concept important pour ces ensembles d'unité de compilation : un moyen de
décrire l'environnement de compilation. Ce concept était également introduit
dans la proposition de Didier Rémi et Gabriel Scherer.

\section{Déclaration et implémentation de namespaces}

En partant de ce principe, il fallait donc trouver ce qu'était l'environnement
de compilation, comment celui-ci était généré et comment l'utilisateur pourrait
l'influencer : en effet, l'un des problèmes majeurs actuels est l'impossibilité
d'utiliser deux unités de compilation de même nom dans un programme. Si
l'environnement est capable de les distinguer cela ne poserait plsu de
problème. Ce qui ressort également de ce problème est que pour que deux modules
de même nom puissent cohabiter dans le système de fichiers, ils doivent être
dans des dossiers distincts : le système de fichiers avec son organisation à
travers une hiérarchie de dossier est un espace de noms. Ainsi, un namespace
pourrait être la projection de l'organisation des modules sur le système de
fichiers.

Cette réflexion nous mène alors à la solution suivante :
\begin{itemize}
\item Un module = un fichier, donc un Namespace = un dossier \\
  $\rightarrow$ le compilateur sait où trouver un module.
\item Pas de manipulation explicite des namespaces dans le coeur du langage pour
  éviter des possibles changements de sémantique \\
  $\rightarrow$ La déclaration des namespaces et l'import des unités de
  compilation se fait en en-tête du code, cet en-tête permet de décrire plus
  finement l'environnement de compilation.
\end{itemize}

De cette manière, le coeur du langage ne subit aucune modification, et de plus,
cela permet d'harmoniser la manière dont sont installés les bibliothèques, ou du
moins propose une organisation standard et permet de réduire le besoin d'outils
externes pour trouver un module (\emph{ocamlfind} par exemple). La syntaxe de
l'en-tête est présentée en (\ref{header-bnf}).

\begin{figure}
\begin{grammar}
<module_name> = <uident>

<header> ::= <namespace_decl> <imports>
\alt <imports>

<namespace_decl> ::= `in' `namespace' <mod_longident>

<imports> ::= <import> <imports> 

<import> ::= (`with'|`and') <ns_conf> 

<ns_conf> ::= `(' <modules_constraints> `)' `of' <mod_longident>

<modules_constraints> ::= <module_constraint>
\alt <module_constraint> `;' <module_constraints>

<modules_constraint> ::= `_'
\alt <module_name> `as' <module_name>
\alt <module_name> `as' `_'
\alt <module_name>
\end{grammar}
\caption{Syntaxe d'un en-tête de fichier \texttt{.ml(i)}}
\label{header-bnf}
\end{figure}

Dans cette syntaxe, il faut noter que l'en-tête est séparé en deux partie
distinctes. Tout d'abord, on remarque que le namespace auquel appartient l'unité
de compilation est déclaré explicitement. Cela permet au compilateur de
récupérer de manière automatique tous les modules susceptibles d'appartenir au
même namespace. De plus, déclarer de manière explicite au compilateur lui permet
de générer le fichier dans le bon dossier. La déclaration d'un namespace n'est
en revanche pas obligatoire.

La seconde partie est la plus intéressante et montre les possibilités de
déclaration de l'environnement de compilation. La déclaration des imports est
lue séquenciellement. Chaque ligne déclare l'ensemble des modules à importer
depuis l'environnement donné. Cet ensemble est déclaré par l'utilisateur, ce qui
lui permet de raffiner ses choix d'après les règles de \texttt{<module_constraint>}:
\begin{itemize}
\item En important module par module;
\item En important un module tout en l'aliasant (\lstinline{Mod as Mod_from_ns});
\item En important tous les modules (\texttt{\_});
\item En masquant un module, pour ne pas inclure tous les modules dans
  l'ensemble généré par la contrainte précédente.
\end{itemize}

Cet en-tête n'existe plus à partir de la phase de typage, et se fait en deux
temps : l'ensemble des modules à rajouter à l'environnement est calculée et le
résultat ajouté à l'environnement. Il ne change rien à la chaîne de compilation,
si ce n'est d'utiliser des informations de namespaces lors de la recherche de
modules dans l'environnement.

Cependant, cet en-tête n'est suffisant pour gérer l'utilisation de modules de
même nom : il est donc nécessaire d'ajouter cette information dans l'unité de
compilation elle-même pour pouvoir l'utiliser comme discriminant lors de
l'édition des liens, mais aussi de modifier les symboles pour y introduire cette
information et donc permettre une différenciation.

Cette solution répond aux problèmes posés par les packs et les modules d'alias :
seuls les modules utilisés sont réellement nécessaires, mais également un
namespace est totalement extensible. En effet, rien n'empêche un autre
utilisateur d'utiliser le même namespace pour y redéfinir certains modules ou en
ajouter.

Finalement, il reste une dernière fonctionnalité manquante par rapport aux
modules d'alias (ou ``modules namespace'') : la possibilité d'avoir du code
accessible de base pour tous les modules. Ce qui a été décidé ici est donc de
donner une sémantique particulière aux unités de compilation ayant pour nom
\emph{Pervasives}. Ainsi, chaque fois qu'un namespace est utilisé et qu'il
contient un module Pervasives, celui-ci est automatiquement ouvert (sauf s'il
est aliasé ou masqué dans les contraintes). De plus, chaque module d'un
namespace ouvre implicitement ce module.

\section{Alternative aux \emph{big functors}}

Le deuxième problème à résoudre est celui de trouver une contrepartie aux
\emph{big functors} pour les namespaces. Pour rappel, les big functors sont une
extension particulière des packs, qui permet au lieu de faire un simple module
comprenant pour sous-modules des unités de compilation d'avoir un pack
``générique''. L'idée est ici d'englober ces sous-modules sous un foncteur, et
ainsi permettre d'abstraire certaines des dépendances de ces modules pour en
faire des arguments de ce foncteur. Ainsi, il devient possible d'avoir des packs
instanciés sous différentes implémentations.

Cette fonctionnalité, qui a été proposée et implémentée par Fabrice Le Fessant
était destinée à la version 3.12 du compilateur, mais n'a jamais été fusionnée
dans les sources officielles. Le patch est néanmoins disponible sur le site
d'OCamlPro. L'idée ici est donc d'imaginer et d''implémenter un mécanisme qui
permettrait d'avoir des namespaces ``génériques'', functorizés et ainsi de
permettre une meilleure réutilisabilité du code.

L'intérêt ici est donc de savoir dans quelle mesure le code était réutilisable
et facilement adaptable, mais aussi de trouver une solution simple à ce
problème. On peut voir cette fonctionnalité comme la contrepartie des ``trous''
de Backpack pour Haskell \cite{KilpatrickDJM14}. Ainsi, la solution à envisager
doit être capable d'avoir des modules qui soient abstraits et aussi de pouvoir
avoir des dépendances qui soient elle-mêmes functorizées sur les mêmes
arguments.

La première partie de la solution était donc de reprendre une partie du code des
big functors. Effet, chaque module qui doit faire partie du pack functorizé doit
être compilé de la manière suivante :
\begin{verbatim}
ocamlc -c -functor arg.cmi my_module.ml
\end{verbatim}
L'option indique que le module \texttt{Arg} dans \texttt{my\_module.ml} est un
argument de foncteur, sa signature est celle de \texttt{arg.cmi} et par
conséquent il n'y a pas de dépendance vers l'unité de compilation
\texttt{arg.cmo}. De plus, si \texttt{My_module} a des dépendances vers d'autres
unités, celles-ci doivent :
\begin{itemize}
\item soit être functorizées sur les mêmes arguments;
\item soit ne pas être functorizées.
\end{itemize}
Ainsi, l'unité de compilation résultante est ce que l'on appelle une
\emph{functor unit}, ou unité functorizée. 

Les functor units ne sont pas utilisable en l'état : il est impossible de les
utiliser dans du code dit ``standard'' (sauf par d'autre functor units dépendant
des mêmes arguments) et ne peuvent être liée directement au
moment de l'édition des liens. Pour pouvoir les utiliser, il faut être capable
de donner une version appliquée de ces unités, autrement dit une instance de
celles-ci appliquées sur une implémentation. On introduit alors une nouvelle
option \texttt{-apply} au compilateur pour donner ces arguments et créer ces
instances. Par exemple, l'instanciation du module précédent serait :
\begin{verbatim}
ocamlc -c -apply inmpl my_module.cmo
\end{verbatim}
Ceci va créer une nouvelle unité de compilation \texttt{my\_module.cmo} qui
donnera \texttt{impl.cmo} à la functor unit et donnera donc un module instancié
sur \texttt{Impl} et donc utilisable normalement. 

Cela étant, cette solution n'est pas complète : le module instancié aura le même
nom que celui de l'unité functorizée. Il sera donc impossible de faire cohabiter
les deux modules dans un même programme, hors l'instance dépend du
foncteur. Pour cela, il faudra que le résultat de l'application soit dans un
nouveau namespace, qui correspondrait donc à un namespace qui serait
l'instanciation d'un autre sur un ensemble d'arguments. Le namespace résultant
de l'application est celui de l'argument donné à la functor unit.

Les propriétés et restrictions de cette implémentation sont les suivantes :
\begin{itemize}
\item Le module donné à \texttt{-functor} doit forcément être une unité de
  compilation qui appartient au même namespace qui celui déclaré dans le fichier
  \texttt{.ml} de l'unité functorizée;
\item Les dépendances functorizées doivent être dans le même namespace;
\item Le résultat de l'application ne peut appartenir au même namespace;
\item Les arguments donnés pour l'application doivent résider dans le même
  namespace;
\item Il doit exister une version appliquée de chaque dépendances functorizée
  dans le namespace pour pouvoir appliquer l'unité, et ces dépendances
  instanciées doivent appartenir au même namespace.
\end{itemize}

De cette manière, il est donc possible de créer des namespaces dont tous les
modules sont functorizés, et donc ensuite de laisser à l'utilisateur le soin
d'instancier ce namespace sur l'implémentation de son choix. Un exemple
d'utilisation est donné dans le chapitre suivant.

\medskip

Un prototype de cette solution est disponible à l'adresse suivante, et avec un
jeu de test et d'exemples.

\chapter{Exemples d'utilisation et analyse}

\section{Namespaces simples}

\subsection{Namespaces hiérarchiques et installation}

La proposition de namespaces actuelles permet par exemple de définir de manière
simple une bibliothèque : en effet, l'utilisation de namespaces permet de ranger
des modules sous un même nom et est ainsi un moyen naturel de décrire, installer
et utiliser des bibliothèques. De plus, ces namespaces étant hiérarchiques, il
est possible de définir des sous-namespaces pour spécifier des comportement dans
une bibliothèque.

Par exemple, une implémentation pour la bibliothèque standard pourrait être la
suivante (on ne prendra que quelques exemples) :
\begin{OCaml}
(* stdlib/list.ml *)
in namespace Stdlib
...
\end{OCaml}

\begin{OCaml}
(* stdlib/unsafe/obj.ml *)
in namespace Stdlib.Unsafe
...
\end{OCaml}

\begin{OCaml}
(* stdlib/internals/camlinternalFormat.ml *)
in namespace Stdlib.Internals
...
\end{OCaml}

Ce que l'on peut constater est qu'il devient alors très facile de déclarer des
bibliothèques. Ainsi, il serait envisageable de rendre le compilateur plus
efficace : puisque l'arborescence des namespaces correspond à l'arborescence du
système de fichiers, le compilateur pourrait être capable dans ce cas de
retrouver simplement les \emph{.cmo ou .cmx} comme il le fait déjà pour les
\emph{.cmis}. De cettte manière, la compilation d'un programme serait simplifiée
lorsqu'il s'agit d'utiliser une bibliothèque externe et ne demanderait donc plus
un système de \emph{build} complet. On pourrait par exemple imaginer un
\texttt{-lib} qui prendrait un nom de dossier en argument et s'occuperait alors
de lire les namespaces et unités de compilation depuis un répertoire
d'installation standard. Avoir un répertoire standard est envisageable grâce à
OPAM qui est devenu le système de gestion de paquets le plus utilisé au sein de
la communauté OCaml. On pourrait ainsi utiliser le compilateur comme le ferait
\emph{ocamlfind} qui s'occupe de donner les arguments nécessaire à la compilation.

Cette proposition de namespace vise ainsi à standardiser la manière dont sont
installées les bibliothèques externes.

\subsection{Extension et redéfinition de namespaces}

Par essence, les namespaces ne sont pas fermés, au contraire des modules qui
une fois compilé ne peuvent être étendus. Il s'agit par ailleurs de l'une des
caractéristiques qui joue en la faveur de ne pas utiliser les modules pour
simuler les namespaces. Ainsi, il est possible d'ajouter des modules dans un
namespace, et donc par conséquent en redéfinir certains. Cela n'impacte en aucun
cas le namespace de base et ne modifie pas ses fichiers : ces redéfinitions et
extensions sont gérées selon l'ordre des unités de compilation données au moment
de l'édition des liens. Chaque bibliothèque s'installe dans un dossier à part,
l'arborescence des unités de compilation n'est pas commune à tous. En effet,
cela pourrait être particulièrement dangereux :
\begin{itemize}
\item Si une biliothèque redéfinit des modules d'un namespace, les unités de
  compilation déjà existantes seraient écrasées;
\item Dans ce cas, si l'utilisateur souhaite désinstaller l'ancienne
  bibliothèque, cela reviendrait à supprimer également les unités qui ont été
  ajoutées par la précédente.
\end{itemize}

Un exemple de redéfinition et d'extension serait :
\begin{OCaml}
(* stdlib/string.ml *)
(* Ce module remplacera le module String du namespace Stdlib *)
...
\end{OCaml}

\begin{OCaml}
(* stdlib/linkedlist.ml *)
(* Ce module implemente des listes chainees de maniere imperative, et donc non
   persistante *)
...
\end{OCaml}

Ainsi, il est possible dans le programme (en supposant que le namespace Stdlib
ne soit pas automatiquement importé) :

\begin{OCaml}
(* my_prog.ml *)
with (_) of Stdlib

type list = Linkedlist.t
\end{OCaml}

\subsection{Utilisation d'unités de compilation de même nom}

Dans l'état actuel de la communauté OCaml, il existe plusieurs libraries dont le
but est de définir une nouvelle bibliothèque standard : on notera notamment Core
et Batteries. Ces dernières utilisent les techniques citées précédemment pour
éviter les conflits : Core utilise un module \texttt{Core} qui est un ensemble
d'alias vers d'autres modules tous préfixés par \texttt{Core_} et Batteries
préfixe tous ses modules par \texttt{Bat_}. De cette manière, il est possible
d'utiliser ces deux biliothèques avec la \texttt{Stdlib} sans avoir de
conflit. Si on supposait que celles-ci étaient réécrites avec des namespaces, il
serait possible de les utiliser conjointement dans un programme. Ce n'est pas un
comportement voulu, mais cela peut avoir une utilité pour réaliser des
benchmarks ou des tests sur des algorithmes.

Par exemple, un programme qui ferait des benchmarks sur les implémentations de
\texttt{Hashtbl} de chacune :
\begin{OCaml}
with (Hashtbl) of Stdlib
and (Hashtbl as CHtbl) of Core
and (Hashtbl as BHtbl) of Batterie

...
let _ =
  let h1 = Hashtbl.create 17 in
  let h2 = CHtbl.create 17 in
  let h3 = BHtbl.create 17 in
  (* une batterie de tests et de comparaison de chacune des operations *)
\end{OCaml}

\subsection{Réflexions sur l'intérêt de ces namespaces}

Les namespaces qui sont proposés ici n'ajoutent rien au langage actuel, le gain
en expressivité n'est pas important, mais l'intérêt se joue particulièrement au
niveau du confort à l'utilisation qu'ils apportent. Le développeur n'a plus à
définir des noms long pour éviter des conflits, l'utilisateur peut décider plus
finement quels modules importer dans son environnement de compilation et lui
évite d'utiliser les noms longs. De plus, ils ne nécessitent pas l'utilisation
d'un outil de compilation de projet particulier comme \emph{Ocamlbuild, OMake,
  ocp-build, Jenga, etc.}. De plus, leur utilisation permet de calculer plus
efficacement les dépendances pour \emph{ocamldep} par exemple : l'outil est donc
capable de donner de meilleures dépendances puisqu'il sait où se trouve chacun
des modules donné dans l'en-tête, et peut se permettre de lire les premiers
tokens des possibles dépendances pour vérifier qu'ils appartiennent au namespace
recherché. De plus, cette solution résoud un problème rencontré lors de
l'utilisation de packs de modules ou de modules d'alias : si l'un des modules
aliasé ou packagé est modifié, alors le module d'alias (ou le pack) doit être
recompilé, et ainsi chacun des modules dont il dépend doit également être
recompilé. Ce goulot d'étranglement peut être évité depuis la 4.02 grâce à la
technique décrite précédemment puis que le module d'alias peut être compilé
avant ceux qu'il référence et donc ne pas avoir de dépendances vers ces
derniers. Néanmoins, cette technique est loin d'être standard et
intuitive. L'intégration de namespaces, qui sont ni plus ni moins que des noms
longs, permet d'éviter ces recompilations inutiles.

L'intérêt d'utiliser un \emph{en-tête} permet de dissocier le mécanisme de
déclaration et d'import du reste du langage. La syntaxe peut cependant paraître
peu naturelle, notamment pour l'import de modules : 
\lstinline{with  ... of...}. 
D'autres langages utilisent le mot-clé \emph{import} qui semble
déjà bien plus clair, néanmoins cela nécessiterait d'ajouter un nouveau mot-clé
au langage (en plus de \texttt{namespace}). Cela n'est bien évidemment pas un
problème au niveau de l'implémentation, mais plutôt à l'utilisation. OCaml est
un langage relativement vieux et pratiquement tous les programmes écrits pour
des versions antérieures seront toujours compilables avec la version
actuelle. Ajouter un mot-clé peut-être dangereux car celui-ci peut être utilisé
comme nom de variable dans l'un de ces programmes et par conséquent n'être plus
compilable. Bien évidemment, modifier le nom d'une variable n'est pas vraiment
un problème, mais cela est à prendre en considération, et explique pourquoi ce
choix de mot-clés qui sont déjà utilisés dans le langage. Une syntaxe plus
naturelle aurait été \texttt{with ... from ...}, mais \texttt{from} est un nom
de variable légitime, par exemple dans une application qui gérerait des
messages, où \texttt{from} pourrait être par exemple l'IP ou le nom de
l'expéditeur.

Leur intérêt se situe particulièrement sur la manière dont peuvent être décrites
les bibliothèques, comment celles-ci sont installées et l'espoir de
standardisation dans l'organisation des bibliothèques du langage. En effet,
cette solution pourrait permettre de ne plus être obligé d'utiliser des outils
tel \emph{ocamlfind} pour des programmes très simples : le compilateur sait
exactement quels modules utiliser si une option comme \texttt{-lib} proposée
précédemment était implémentée. En revanche, le compilateur ne peut créer
lui-même les dossiers correspondant aux namespaces sur le système de fichiers :
cela entrainerait une dépendance vers le module \emph{Unix} et donc entamerait
la portabilité du compilateur, celle-ci étant déjà précaire. Néanmoins, ce
défaut n'en est pas vraiment un :
\begin{itemize}
\item Un utilisateur n'utilisera pas de namespaces pour des programmes simples,
  leur utilité est vraiment de dissocier des ensembles de modules.
\item Il est possible de retrouver deux modules avec le même nom dans deux
  namespaces différents et de les utiliser conjointement. Le seul moyen d'avoir
  les deux fichiers sources est donc de les dissocier à l'aide de dossier. Il
  est possible de leur donner un nom différent et de les renommer à la
  compilation à l'aide de \texttt{-o}, mais cette fonctionnalité n'a pas de sens
  et n'aide pas à la relecture du programme ou de la bibliothèque.
\end{itemize}

L'implémentation actuelle modifie légèrement le type des alias de modules
(introduit dans la verson 4.02) : le type qui à l'origine contient le chemin
vers l'unité aliasée (ou le module) contient également le namespace d'où
provient le module. Cette information n'est utilisée qu'à la normalisation des
chemins pour justement substituer les alias par le veritable chemin, et par
conséquent ne modifie pas la sémantique du langage et du système de types.
En interne, les symboles sont légèrement modifiés pour devenir des noms longs de
la forme \texttt{<namespace>@<module>}, ce qui permet donc de différencier des
unités de compilation de même nom mais de provenance différente. Ces symboles ne
sont bien sûr pas reconnu par le langage et une telle syntaxe n'est donc pas
parsable. De ce fait, il est nécessaire de realiaser les expressions lorsque le
\emph{.mli} est inféré à l'aide de l'option \texttt{-i} du compilateur.

Utiliser un namespace n'est bien évidemment pas une obligation, et tout
programme compilable à l'aide de la version 4.02 l'est avec le compilateur
patché pour les namespaces.

L'intérêt également de cette approche est qu'elle permet de mieux comprendre
l'architecture d'un programme. En effet, il est parfois difficile de relire un
code qui utilise plusieurs bibliothèques en même temps. L'utilisation de
l'en-tête permet de connaître la provenance des modules, mais également d'aider
un utilisateur externe à compiler le programme dans le cas où la chaîne de
compilation n'est pas disponible.

Au final, cette solution satisfait l'ensemble des contraintes imposées dans la
problématique.

\section{Utilisation des functor units}

\subsection{Cas d'utilisation}

Supposons que l'on écrive une biliothèque pour écrire des serveurs web. En
particulier, un serveur doit pouvoir gérer plusieurs requètes en même temps, et
nécessite donc d'être capable de paralléliser celles-ci. On peut par exemple
prendre le cas de \emph{CoHTTP}, qui utilise \emph{Lwt} ou \emph{Async}, deux
bibliothèques écrites sous forme monadiques, pour la partie concurrence du
traitement des requètes. Si un seul module est dépendant de l'implémentation de
la monade concurrente, un simple foncteur est suffisant. En revanche, si
l'ensemble de la bibliothèque dépend de cette implémentation, la seule solution
est d'avoir un fichier de base qui \emph{bind} l'une ou l'autre des
implémentations au moment de la configuration de l'environnement (donc avant la
compilation). En effet, utiliser un foncteur pour ce fichier de bindings n'est
pas envisageable : le foncteur devrait donc être appliqué dans chaque module qui
l'utilise, et le code d'initialisation (s'il y en a) serait exécuté à chaque
fois.

La solution des functor units permet à l'ensemble de la bibliothèque d'être
complètement abstraite sur l'interface de cette monade, et donc par la suite de
créer un namespace qui serait l'instantiation de cette bibliothèque sur cette
monade. Voici un exemple concret :

\begin{OCaml}
(* cohttp/asyncMonad.mli *)
in namespace Cohttp

type 'a t

val (>>=) : 'a t -> ('a -> 'b t) -> 'b t

val return : 'a -> 'a t
val bind : 'a t -> ('a -> 'b t) -> 'b t (* == (>>=) *)
val poll : 'a t -> 'a option
...
\end{OCaml}

\begin{OCaml}
(* cohttp/requestHandler.ml *)
in namespace Cohttp
...
let M = AsyncMonad
...
\end{OCaml}

\begin{OCaml}
(* cohttp/protocol.ml *)
in namespace Cohttp
...
open RequestHandler
\end{OCaml}

Le namespace Cohttp contient donc le code générique pour un serveur HTTP (on
supposera que ces deux modules sont suffisant, il ne s'agit pas d'un exemple de
la véritable bibliothèque Cohttp). La compilation de ces modules serait :
\begin{verbatim}
ocamlc -c cohttp/asyncMonad.mli
ocamlc -c -functor cohttp/asyncMonad.cmi cohttp/requestHandler.ml
ocamlc -c -functor cohttp/asyncMonad.cmi cohttp/protocol.ml
\end{verbatim}

Dans cet exemple, le module Protocol ne fait jamais explicitement référence à
AsyncMonad, néanmoins pour pouvoir utiliser RequestHandler il doit être
functorizé sur les mêmes arguments que lui.

On souhaite ensuite instancier une version de la bibliothèque sur Lwt. On crée
donc un nouveau namespace Cohttp.Lwt, et un fichier qui bind le module Lwt dans
ce namespace. On suppose que Lwt appartient au namespace Ocsigen :
\begin{OCaml}
(* cohttp/lwt/monad.ml *)
in namespace Cohttp.Lwt
with (Lwt) of Ocsigen

type 'a t = 'a Lwt.t

let (>>=) = Lwt.(>>=)
let return = Lwt.return
let bind = Lwt.bind
let poll = Lwt.poll
...
\end{OCaml} 

Il est désormais possible d'instancier la bibliothèque sur cette monade :

\begin{verbatim}
ocamlc -c cohttp/lwt/monad.ml
ocamlc -c -apply cohttp/lwt/monad.cmo cohttp/requestHandler.cmo
ocamlc -c -apply cohttp/lwt/monad.cmo cohttp/protocol.cmo
\end{verbatim}

Si finalement on écrit un serveur très simple à l'aide de Cohttp.Lwt :
\begin{OCaml}
(* my_server.ml *)
with (Protocol) of Cohttp.Lwt

...
\end{OCaml}

La compilation sera alors :

\begin{verbatim}
ocamlc -o server cohttp/requestHandler.cmo cohttp/protocol.cmo \
    cohttp/lwt/monad.ml cohttp/lwt/requestHandler.cmo cohttp/lwt/protocol.cmo \
    my_server.ml 
\end{verbatim}

On remarque que la ligne de compilation parait très longue, mais cela se
justifie du fait que les versions instanciées sont toujours dépendantes des
functor units qu'elles instancient : tout le code se trouve dans ces functor
units, les instances ne font qu'appliquer les arguments.

\subsection{Réflexion sur l'implémentation et le choix des functor units}

La solution pour avoir des namespaces functorizée est moins élégante que celle
des namespaces : en effet, ici tout se passe du côté de la chaîne de compilation
et nécessite de mettre en place un système de build ou d'utiliser un outil
capable de comprendre et gérer ces functor units et leur instantiation. L'un des
objectifs n'est pas atteint. Néanmoins, le gain en expressivité est réel,
puisqu'il devient possible de définir des bibliothèques génériques.

Certaines restrictions pourraient être levées ou du moins allégées dans une
possible mise-à-jour:
\begin{itemize}
\item Le fait que le module sur lequel est appliquée la functor unit pourrait ne
  pas appartenir au même namespace (on pourrait utiliser Lwt directement), mais
  se justifie car il est rare que l'interface du module que l'on souhaite
  utiliser lors de l'instantiation ait une interface directement compatible. Le
  plus souvent, il faudra écrire un module qui \emph{bind} l'argument vers la
  bonne interface.
\item Dans la version actuelle, la currification n'est pas possible. Ce n'est
  que par soucis de simplicité et cela serait réalisable.
\item En terme de dépendances, dans les big functors deux unités sont
  compatibles si les arguments de la dépendances sont un sous-ensemble des
  arguments de l'unité en cours de compilation. Cela devrait être également
  possible dans l'implémentation actuelle.
\end{itemize}

Sans functor-units il serait possible de créer des bibliothèques ayant le même
comportement. Il suffirait que le code de chaque module doit contenu dans un
foncteur, et que chacunes des dépendances soient explicitement instanciées en
utilisant l'argument de ce foncteur. Néanmoins, cette solution a plusieurs
défauts :
\begin{itemize}
\item Pour pouvoir utiliser un module, il faut à chaque fois l'instancier. Cela
  n'est pas tellement un problème du point de vue des types puisque les
  foncteurs d'OCaml sont applicatifs, et par conséquent deux instances de
  foncteurs sont identiques du point de vue des types si leur argument est le
  même. En revanche, l'application du foncteur a un coup non négligeable, et si
  code d'initialisation il y a celui-ci est executé à chaque fois. De la même
  manière, tout effet de bord ou référence sera propre à chaque instance et non
  pas partagé entre celles-ci malgré qu'elles soient identiques du point de vue
  du système de types.
\item Le module pourrait être instancié une seule fois et inclus dans un nouveau
  module :
\begin{OCaml}
(* protocol_lwt.ml *)
module M = Protocol.Make(Lwt)
include M
\end{OCaml}
Néanmoins, dans cette solution les dépendances sont appliquées à chaque fois, le
compilateur est incapable de détecter qu'il y a déjà eu application. Au
contraire, l'application d'une functor units nécessite que ses dépendances qui
sont functorisées sur les mêmes arguments existe dans le même namespace pour
pouvoir \texttt{explicitement} les utiliser. 
\end{itemize}

Par conséquent, cette solution peut être imitée dans le langage actuel avec la
restriction de ne pas avoir d'effets de bords (donc pas de code
d'initialisation) et de code mutable, et avec la contrainte que le foncteur sera
chaque fois appliqué (que soit directement ou indirectement), même s'il existe
déjà une instance de celui-ci appliqué sur le même argument.

\chapter{Conclusion et perspective}

La problématique des namespaces est un sujet intéressant : il s'agit d'abord
d'un sujet de discussion récurrent au sein de la communauté, avec de nombreuses
idées mais sans jamais aucun accord entre les participants. Bien qu'ils n'apportent
pas un gain évident en expressivité, ils permettent plus de confort pour le
développeur et l'utilisateur. Les namespaces sont un excellent moyen de décrire
une bibliothèque dans le langage, mais aussi d'apporter un standard dans la
manière dont sont installées celles-ci sur le système de fichiers, et permet
également de simplifier le travail du compilateur sans nécessiter d'outils
externes (le moins possible en tout cas). L'intérêt de notre approche est
qu'elle ne modifie pas un système de types déjà compliqué et ainsi ne demande
pas de vérifier et prouver la sûreté et la complétude de la solution, et donc
qu'elle ne change pas la sémantique actuelle du langage.

L'idée d'avoir un moyen de déclarer des namespaces génériques est intéressante
et logique dans le contexte de la programmation fonctionnelle où le code d'un
programme est facilement réutilisable grâce aux fonctions d'ordre supérieur. La
solution demande un peu d'effort au niveau de la chaîne de compilation
néanmoins, et n'est pas aussi simple que celle des namespaces. La solution de
namespaces proposée ici se rapproche en particulier de la mécanique des packages
de Java ou Scala, avec la généricité des packages de Backpack.

Le but de ce stage est de réouvrir la discussion sur le besoin de namespaces,
mais en apportant cette fois une solution concrète et non seulement des
idées. L'espoir est donc de faire converger la communauté vers une solution
définitive. Le prototype permet notamment aux différents acteurs de se faire une
idée sur notre proposition. Cette proposition sera d'ailleurs présentée durant
l'ICFP 2014, à l'OCaml Users and Developpers Workshop le 6 septembre.

Par la suite, il est évident que si cette solution plait il deviendra nécessaire
de continuer à travailler sur ce prototype, que ce soit en terme de nettoyage du
code, de refactorisation mais surtout pour modifier ou ajouter certaines
fonctionnalités dans le but de pouvoir intégrer cette mécanique au langage. En
ce sens, il pourrait être intéressant par la suite de pouvoir accéder à des
modules directement dans le programme sans import préalable. Pour cela, il
faudra définir une syntaxe claire et modifier légèrement le système de types
pour prendre en compte ces nouvelles informations.

Une autre idée qui serait intéressante serait d'avoir la capacité pour le
compilateur de compiler un programme en lui donnant simplement le fichier
d'entrée, comme le ferait \emph{ocamlbuild}. Cela serait possible grâce à la
correspondance entre les namespaces et le système de fichiers et la
simplification du calcul des dépendances. Dans cette optique, il serait
également intéressant de modifier les systèmes de builds actuels pour qu'ils
utilisent les namespaces et les functor units. Un langage de description de
programme comme celui d'\emph{ocp-build} pourrait permettre de facilement
déclarer des unités functorisées et leurs applications.

\bibliographystyle{plain}
\bibliography{biblio}

\appendix

\chapter{Formalisme simple de l'édition des liens avant et après 4.02}
\label{appendix-soa}

Cette annexe est tirée de la proposition de namespaces pour 4.02. Celle-ci est
découpée en deux parties : un état de l'art sur la manière de simuler les
namespaces avec des exemples et une formalisation relativement simplifiée du
mécanisme de l'édition des liens. Cette partie est intéressante notamment pour
expliquer comment l'ajout des alias de modules a changé l'édition des liens et
la gestion des dépendances pour pouvoir compiler un programme. Cette partie est
rédigée en anglais, puisqu'elle est directement tirée de la proposition.


\input{linking-form}

\chapter{Proposition originelle}

L'annexe qui suit est la version finale de la proposition de namespaces écrite
comme référence pour la communauté. Elle n'est pas forcément utile pour
comprendre ce rapport mais fait parti du travail effectué durant ce stage.

\input{proposal}

\end{document}
