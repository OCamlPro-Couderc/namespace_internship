* intro

*** presentation (...) ***
Some of you maybe know the subject, since it is recurrent amongst the
community. Namespaces in OCaml is a long topic, with many ideas, and believe me
I've read them all, but unfortunately there never have been any agreement on a
solution. The problem is that everyone had its idea of how they would be useful
in their case, and proposed a solution, but that would not satisfy everyone and
not even compatible with other suggestions.

What we decided is to propose a solution that maybe not satisfy everyone, but
with a working prototype so that anyone can try it. We hope this would lead to
an agreement and possibly an implementation into the compiler.

Another topic I will mention is the implementation of big functors, that allows
some kind of parametric namespaces.

* Need of namespace

First of all, I'd like to explain or remind you what are the reasons for
namespaces in OCaml. The current problem is that we cannot use two compilation
units with the same name in a program. That's logical since there is no way to
distinguish them, but it can be troublesome in terms of scalability. For
example, many libraries have a Misc or Utils module, that contains generic
functions used everywhere. As a result, it is not possible to link two libraries
that both have such a module, and developpers have to use tricks to avoid this
issue.

The simplest one is by using long names, by just prefixing the module by the
name of the library for example. However, it can be really verbose since names
can tend to be quite long.

The second one is using packs: it simply takes every compilation units and wraps
them in a module. The pack can then be used as a module. But in terms of
performance, it's terrible : dependencies can be hard to compute, it is a
bottleneck for recompilation and every compilation unit is linked with the
program, even if only one is used.

The last one is what I like to call an hybrid of the previous two. You still use
long names, but you write a module that is simply a list of aliases. When
writing your library, you still use those long names but the user can use short
names. Before 4.02 it had the same problems as the packs, expect it wasn't
generated by the compiler and thus it allows to have values in the module. With
the new version of the compiler, aliases that are not used in the program does
not have to be linked nor even be present to compile the aliaser module. The
problem is is would need a strong build system to avoid unnecessary
recompilation, but I won't talk about it, Jacques explained it yesterday.

* What namespaces are

What we need to resolve is "What are namespaces?". What we've seen is that we
need a mechanism to be able to distinguish two compilation units of the same
name. Other languages have such a mechanism: that's packages in Java or Scala
for example. But does it need to change the semantics of the language to support
them? Not really. For example in thos languages, you can imports classes into
the environment using an import directive, and actually this is just what we
need. As long as we can import a name that represent a module in the
environment, it should be enough. 

What we actually need is a meaning to declare libraries directly in the source
code, not only on the build system side.

* Writing Mylib with namespace

I've shown you an example previously, of a simple library that contains a Map
and a Set module. If we want to use them with those from the standard library
for example, we would need to use the previous tricks. Here is how we would do
it with our solution: the first line of each module is simply a declaration of
namespace: it tells that this file is a module that belong to a namespace called
Mylib. 

This is also interesting to notice that the result of the compilation will be
placed in a mylib subdirectory. I'll talk abotu it later, but remind it.

* Using our library

What if we want to use those modules? The problem is, how can we refer to them?
Simply List or Map won't be enough. What we do, is importing them in the
environment. This line just says "I'll use List and Map from the namespace
Mylib". The problem is that now, the name List is bound to the one from
Mylib. What if we want to also use List from the standard library? The solution
is to import List and alias it, like this.

* Import possibilities

The problem is that we could want to use all modules, or at least many without
importing them one by one. For example, if I suppose Batteries have been
rewritten using namespaces, I could simply use its modules by importing them
with a wildcard.

The problem with this solution is that it imports all modules, but it maybe
would shadow some already existing names. For example, I would like to use the
List module from the standard library and still use Batteries, I just simply
import all of them, except List. If I wanted to also use List from Batteries, I
would alias it directly.

Some of you that knows a little bit of Scala will recognizes those imports
constraints, since this is were we took our inspiration.

* Header

Is is important to notice that those imports can only happen at the beginning of
the file, before any declaration. It is simply a kinf of header that only
declares the current namespace and imports the necessary name into the
environment. With this solution, the core language and the type systems remains
intact. What changes are simply the symbols that are generated at compilation to
allow to distinguish and link modules with the same name.

* Filesystem

Another property from other languages is that namespaces, or packages, are
actually translated as directories on the filesystem. This is what I've shown
you earlier: my modules from Mylib where placed in a subdirectoty named
mylib. That's logical, since two compilation units cannot coexists in the same
directory. 

* Advantages

There are many advantages using this solution:
- First of all, there's no recompilation issues with namespaces. With packs or
modules full of aliases, if one unit changed you had to recompile the pack and
then every modules that depended on the pack. In our case, you only recompile
modules that effectively use those that changed.
- Dependencies can be computed syntactically, since ocamldep only needs to read
the header and simply read the first statement of files that corresponds to
modules that are not present in the imports.
- Namespaces are hierarchical: you can have subnamespaces.
- With the use of namespace as discriminant, you can use two compilation units
with the same name
- The OCaml core semantics is intact
- Actually, this mechanism uses kind of long name to help distinguish modules,
but it if far more expressive thanks to the imports directive.
- They are not mandatory, any program or library that is compilable with the
4.02 version of the compiler still works. The semantics does not change: modules
without namespace does not have to be imported, the compiler will look for them
if names aren't already binded in the environment.

* Drawbacks

However, there's at least one drawback: the modules are placed in the
subdirectory that corresponds to the namespace, but the compiler cannot create
those subdirectories. However, I think this is not really a problem. If you make
a simple program, you don't need a namespace. However, if you use namespaces,
you will need directories to distinguish files with the same name. It simply
forces to organize a bit the sources.

I don't see any other major drawbacks, except that you cannot manipulate
namespaces directly in the program, but we have a solution for that. If you
think of any, don't hesitate to tell me, I may have forgotten to mention a
feature or forgot some cases.

* Big functors

As I mentionned at the beginning of this talk, we also worked on a counterpart
of big functors with namespaces. For those that have never heard of them, big
functors, or functor-parts, are a work from Fabrice Le Fessant to generate packs
that actually wrapped the compilation unit in a functor. That would transform some
dependencies of those units as arguments of the functor.

Packs were actually a workaround for namespaces, it does make sens to have
parametric namespaces that are functorized over some interfaces, like big
functors.

* Simplest solution

Currently, it is already possible to make parametric modules, like Map or Set:
you simply wrap the entire code in a functor that you instantiate
later. However, what big functor solved was it managed dependencies. For
example, suppose I want to write an Http server, with two modules:
RequestHandler and Protocol. It maybe does not make sense, it's just for the
example. To be able to manage multiple request, I decide to use a monadic
library, like Lwt or Async, but I want to let the choice to the user. What I
could have done is using a ./configure, but I cannot have both libraries : one
using Async and the other Lwt.

For example, I would write a functor that wraps the code of RequestHandler.
I do the same for the module Protocal, which is dependent on RequestHandler. I
need to instantiate the functor to be able to use it.

* Drawbacks of simplest solution

The problem is if I have multiple files that use RequestHandler: it will be
instantiated multiple time. If it does side effects, they will be computed each
time and that can lead to a disaster, and if it has some references, they won't
be shared between each instances.

* Solution

Our solution are the concept of functor units. In other words, we compile a
module and directly wrap it directly in the functor. It cannot be used directly
in the program but will need to be applied. The advantages are that every
functor is instantiated once, and dependencies are correctly managed. 

But this won't help you to understand, I will show you a complete example.

* Compiling a functor unit

I want to write the same example as previously, instead I will use those functor
units this time.

I declare the signature of the monad I want to use in a separate file. As you
can see, it does look like th interface of Lwt for example. Each of my files
will use explicitely this interface.

At compilation, I specifiy that the compilation unit AsyncMonad refered in the
source file is actually a functor argument. 

We simply write our library as any other one, and let the compiler take care of
functorization and functorized dependencies.

* Instantiation

However, we cannot directly use this library in a program since it is a functor,
the solution is to instantiate it with an implementation that satisfies that
arguments. For example, if we suppose I want to instantiate the library over
Lwt, we will create a new namespace that corresponds to the instantiation. We
cannot use the same namespace since modules names will overlap. The namespace
will be the same as the arguments given, in our case it will be in a
subnamespace of the original.

We simply apply the cmi on the functor unit, that will result into a new cmo
that corresponds to the instantiation.

* Restrictions

Functor units are special cases of compilation unit, and can be used with some
restrictions:
- It can have dependencies, that either are functor units on the same arguments
or not functorized at all.
- It cannot be currified
- The application of every units on the same arguments must belong to the same
namespace. Since dependencies are managed by the compiler, when you apply your
functor every dependencies that were functorized must belong to the same
namespace. The compiler simply looks for modules of the same name and verifies
they are applied on the same arguments.

* Prototype

Every feature that I showed you are actually implemented in a prototype that is
based on the last 4.02 revision. There maybe some bugs remaining, but you can
play with thoses namespaces and functor-units, and some examples are available.

* Conclusion

This solution I showed you maybe not what you expected, there may be some holes
that we didn't noticed, but it a solution that actually works. What we hope is
some feedback, maybe even rekindle the discussion.

There is some work to do obviously, first of all there's a major cleaning and
refactoring to do in the code. We also want to remove some restrictions with
functor units, for example allowing currification which shouldn't be that hard,
except it would generate functor-units that are the result of the application of
other functor units, and that maybe needs some thoughts. Another restriction is
about the functorized dependencies whose arguments must match those from the
currently compiled unit. We can simply imagine those dependenciez to be
functorized on a subset of these arguments.

Another improvements can also be the ideas from the OCaml community for
example. Finally, another feature we started working on are namespaces coerced
to modules. Instead of importing, the header can create a structure that matches
the namespaces and modules imported. For example, it could allow to use such
structures as arguments of functors or as first order modules. It is an early
experiment that actually works in the prototype but is not efficient at all and
needs some improvements.

